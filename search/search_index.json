{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python JSONPath","text":"<p>JSONPath is a mini language for selecting objects from data formatted in JavaScript Object Notation, or equivalent Python objects, like dictionaries and lists.</p>"},{"location":"#install","title":"Install","text":"<p>Install Python JSONPath using pip:</p> <pre><code>pip install python-jsonpath\n</code></pre> <p>Or Pipenv:</p> <pre><code>pipenv install python-jsonpath\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>import jsonpath\nexample_data = {\n\"categories\": [\n{\n\"name\": \"footwear\",\n\"products\": [\n{\n\"title\": \"Trainers\",\n\"description\": \"Fashionable trainers.\",\n\"price\": 89.99,\n},\n{\n\"title\": \"Barefoot Trainers\",\n\"description\": \"Running trainers.\",\n\"price\": 130.00,\n},\n],\n},\n{\n\"name\": \"headwear\",\n\"products\": [\n{\n\"title\": \"Cap\",\n\"description\": \"Baseball cap\",\n\"price\": 15.00,\n},\n{\n\"title\": \"Beanie\",\n\"description\": \"Winter running hat.\",\n\"price\": 9.00,\n},\n],\n},\n],\n\"price_cap\": 10,\n}\nproducts = jsonpath.findall(\"$..products.*\", example_data)\nprint(products)\n</code></pre> <p>Which results in a list of all products from all categories:</p> <pre><code>[\n{\n\"title\": \"Trainers\",\n\"description\": \"Fashionable trainers.\",\n\"price\": 89.99\n},\n{\n\"title\": \"Barefoot Trainers\",\n\"description\": \"Running trainers.\",\n\"price\": 130.0\n},\n{\n\"title\": \"Cap\",\n\"description\": \"Baseball cap\",\n\"price\": 15.0\n},\n{\n\"title\": \"Beanie\",\n\"description\": \"Winter running hat.\",\n\"price\": 9.0\n}\n]\n</code></pre> <p>Or, reading data from a JSON formatted file:</p> <pre><code>import jsonpath\nwith open(\"some.json\") as fd:\nproducts = jsonpath.findall(\"$..products.*\", fd)\nprint(products)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Have a read through the Quick Start and High Level API Reference.</p> <p>If you're interested in customizing JSONPath, take a look at Advanced Usage and the Low Level API Reference.</p>"},{"location":"advanced/","title":"Advanced","text":"<p>TODO</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#jsonpath.JSONPathEnvironment","title":"jsonpath.JSONPathEnvironment","text":"<p>JSONPath configuration.</p> <p>This class contains settings for path tokenization, parsing and resolution behavior, plus convenience methods for matching an unparsed path to some data.</p> <p>Most applications will want to create a single <code>JSONPathEnvironment</code>, or use <code>jsonpath.compile()</code>, <code>jsonpath.findall()</code>, etc. from the package-level default environment.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment--environment-customization","title":"Environment customization","text":"<p>Environment customization is achieved by subclassing <code>JSONPathEnvironment</code> and overriding class attributes and/or methods. Some of these customizations include:</p> <ul> <li>Changing the root (<code>$</code>), self (<code>@</code>) or filter context (<code>#</code>) token with   class attributes <code>root_token</code>, <code>self_token</code> and <code>filter_context_token</code>.</li> <li>Registering a custom lexer or parser with the class attributes   <code>lexer_class</code> or <code>parser_class</code>. <code>lexer_class</code> must be a subclass of   <code>Lexer</code> and <code>parser_class</code> must be a subclass of <code>Parser</code>.</li> <li>Setup built-in function extensions by overriding   <code>setup_function_extensions()</code></li> <li>Hook in to mapping and sequence item getting by overriding <code>getitem()</code>.</li> <li>Change filter comparison operator behavior by overriding <code>compare()</code>.</li> </ul>"},{"location":"api/#jsonpath.JSONPathEnvironment--class-attributes","title":"Class attributes","text":"ATTRIBUTE DESCRIPTION <code>intersection_token</code> <p>The pattern used as the intersection operator.</p> <p> TYPE: <code>str</code> </p> <code>root_token</code> <p>The pattern used to select the root node in a JSON document.</p> <p> TYPE: <code>str</code> </p> <code>self_token</code> <p>The pattern used to select the current node in a JSON document.</p> <p> TYPE: <code>str</code> </p> <code>union_token</code> <p>The pattern used as the union operator.</p> <p> TYPE: <code>str</code> </p> <code>filter_context_token</code> <p>The pattern used to select extra filter context data.</p> <p> TYPE: <code>str</code> </p> <code>lexer_class</code> <p>The lexer to use when tokenizing path strings.</p> <p> TYPE: <code>Type[Lexer]</code> </p> <code>parser_class</code> <p>The parser to use when parsing tokens from the lexer.</p> <p> TYPE: <code>Type[Parser]</code> </p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.function_extensions","title":"function_extensions  <code>instance-attribute</code>","text":"<pre><code>function_extensions: Dict[str, Callable[..., Any]] = {}\n</code></pre> <p>A list of function extensions available to filters.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.lexer","title":"lexer  <code>instance-attribute</code>","text":"<pre><code>lexer: Lexer = self.lexer_class(env=self)\n</code></pre> <p>The lexer bound to this environment.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.parser","title":"parser  <code>instance-attribute</code>","text":"<pre><code>parser: Parser = self.parser_class(env=self)\n</code></pre> <p>The parser bound to this environment.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.compare","title":"compare","text":"<pre><code>compare(left: object, operator: str, right: object) -&gt; bool\n</code></pre> <p>Object comparison within JSONPath filters.</p> <p>Override this to customize filter expression comparison operator behavior.</p> PARAMETER DESCRIPTION <code>left</code> <p>The left hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> <code>operator</code> <p>The comparison expression's operator.</p> <p> TYPE: <code>str</code> </p> <code>right</code> <p>The right hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the comparison between left and right, with the</p> <code>bool</code> <p>given operator, is truthy. <code>False</code> otherwise.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.compile","title":"compile","text":"<pre><code>compile(path: str) -&gt; Union[JSONPath, CompoundJSONPath]\n</code></pre> <p>Prepare a path string ready for repeated matching against different data.</p> PARAMETER DESCRIPTION <code>path</code> <p>A JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Union[JSONPath, CompoundJSONPath]</code> <p>A <code>JSONPath</code> or <code>CompoundJSONPath</code>, ready to match against some data. Expect a <code>CompoundJSONPath</code> if the path string uses the union or intersection operators.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.findall","title":"findall","text":"<pre><code>findall(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.finditer","title":"finditer","text":"<pre><code>finditer(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> <p>Raises a <code>JSONPathSyntaxError</code> if the path is invalid.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.getitem","title":"getitem","text":"<pre><code>getitem(obj: Any, key: Any) -&gt; Any\n</code></pre> <p>Sequence and mapping item getter used throughout JSONPath resolution.</p> <p>The default implementation of <code>getitem</code> simply calls <code>operators.getitem()</code> from Python's standard library. Same as <code>obj[key]</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>A mapping or sequence that might contain key.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>A mapping key, sequence index or sequence slice.</p> <p> TYPE: <code>Any</code> </p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.getitem_async","title":"getitem_async  <code>async</code>","text":"<pre><code>getitem_async(obj: Any, key: object) -&gt; Any\n</code></pre> <p>An async sequence and mapping item getter.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.is_truthy","title":"is_truthy","text":"<pre><code>is_truthy(obj: object) -&gt; bool\n</code></pre> <p>Test for truthiness when evaluating JSONPath filter expressions.</p> <p>In some cases, the IETF JSONPath draft requires us to test for existence rather than truthiness. So the default implementation returns <code>True</code> for empty collections and <code>None</code>. The special <code>UNDEFINED</code> object means that obj was missing, as opposed to an explicit <code>None</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>Any object.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the object exists and is not <code>False</code> or <code>0</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.setup_function_extensions","title":"setup_function_extensions","text":"<pre><code>setup_function_extensions() -&gt; None\n</code></pre> <p>Initialize function extensions.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.validate_function_extension_signature","title":"validate_function_extension_signature","text":"<pre><code>validate_function_extension_signature(\ntoken: Token, args: List[Any]\n) -&gt; None\n</code></pre> <p>Compile-time validation of function extension arguments.</p> <p>The IETF JSONPath draft requires us to reject paths that use filter functions with too many or too few arguments.</p>"},{"location":"api/#jsonpath.JSONPathMatch","title":"jsonpath.JSONPathMatch","text":"<p>A matched object with a concrete path.</p> ATTRIBUTE DESCRIPTION <code>children</code> <p>Matched child nodes. This will only be populated after all children have been visited, usually by using <code>findall()</code> or <code>list(finditer())</code>.</p> <p> TYPE: <code>List[JSONPathMatch]</code> </p> <code>obj</code> <p>The matched object.</p> <p> TYPE: <code>object</code> </p> <code>parent</code> <p>The immediate parent to this match in the JSON document. If this is the root node, parent will be <code>None</code>.</p> <p> TYPE: <code>Optional[JSONPathMatch]</code> </p> <code>path</code> <p>The canonical string representation of the path to this match.</p> <p> TYPE: <code>str</code> </p> <code>parts</code> <p>The keys, indices and/or slices that make up the path to this match.</p> <p> TYPE: <code>Tuple[PathPart, ...]</code> </p> <code>root</code> <p>A reference to the root node in the JSON document.</p> <p> TYPE: <code>Union[Sequence[Any], Mapping[str, Any]]</code> </p>"},{"location":"api/#jsonpath.match.JSONPathMatch.add_child","title":"add_child","text":"<pre><code>add_child(*children: JSONPathMatch) -&gt; None\n</code></pre> <p>Append one or more children to this match.</p>"},{"location":"api/#jsonpath.match.JSONPathMatch.filter_context","title":"filter_context","text":"<pre><code>filter_context() -&gt; FilterContextVars\n</code></pre> <p>Return filter context data for this match.</p>"},{"location":"api/#jsonpath.JSONPath","title":"jsonpath.JSONPath","text":"<p>A compiled JSONPath ready to be applied to a JSON string or Python object.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>JSONPathEnvironment</code> this path is bound to.</p> <p> TYPE: <code>JSONPathEnvironment</code> </p> <code>selectors</code> <p>An iterable of <code>JSONPathSelector</code> objects, as generated by a <code>Parser</code>.</p> <p> TYPE: <code>Iterable[JSONPathSelector]</code> </p>"},{"location":"api/#jsonpath.path.JSONPath.empty","title":"empty","text":"<pre><code>empty() -&gt; bool\n</code></pre> <p>Return <code>True</code> if this path has no selectors.</p>"},{"location":"api/#jsonpath.path.JSONPath.findall","title":"findall","text":"<pre><code>findall(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will</p> <code>List[object]</code> <p>be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.path.JSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> If the path is invalid. <p>JSONPathTypeError: If a filter expression attempts to use types in     an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.CompoundJSONPath","title":"jsonpath.CompoundJSONPath","text":"<p>Multiple <code>JSONPath</code>s combined.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.findall","title":"findall","text":"<pre><code>findall(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.intersection","title":"intersection","text":"<pre><code>intersection(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>In-place intersection of this path and another path.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.union","title":"union","text":"<pre><code>union(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>In-place union of this path and another path.</p>"},{"location":"async/","title":"Async","text":"<p>TODO</p>"},{"location":"custom_api/","title":"Low Level API Reference","text":"<p>TODO</p>"},{"location":"exceptions/","title":"Exceptions","text":""},{"location":"exceptions/#jsonpath.JSONPathError","title":"jsonpath.JSONPathError","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for all JSONPath syntax and type errors.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Optional[Token]</code> DEFAULT: <code>None</code> </p>"},{"location":"quickstart/","title":"Quick start","text":"<p>TODO</p>"}]}