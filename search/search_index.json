{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python JSONPath","text":"<p>JSONPath is a mini language for selecting objects from data formatted in JavaScript Object Notation, or equivalent Python objects, like dictionaries and lists.</p> <p>Python JSONPath is a non-evaluating, read-only implementation of JSONPath, suitable for situations where JSONPath query authors are untrusted. We follow most of the IETF JSONPath draft. See Notable differences for a list of areas where we deviate from the standard.</p> <p>Since version 0.8.0, we also include implementations of JSON Pointer (RFC 6901) and JSON Patch (RFC 6902), plus methods for converting a JSONPathMatch to a <code>JSONPointer</code>.</p>"},{"location":"#install","title":"Install","text":"<p>Install Python JSONPath using pip:</p> <pre><code>pip install python-jsonpath\n</code></pre> <p>Or Pipenv:</p> <pre><code>pipenv install python-jsonpath\n</code></pre> <p>Or pipx</p> <pre><code>pipx install python-jsonpath\n</code></pre> <p>Or from conda-forge:</p> <pre><code>conda install -c conda-forge python-jsonpath\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>import jsonpath\nexample_data = {\n\"categories\": [\n{\n\"name\": \"footwear\",\n\"products\": [\n{\n\"title\": \"Trainers\",\n\"description\": \"Fashionable trainers.\",\n\"price\": 89.99,\n},\n{\n\"title\": \"Barefoot Trainers\",\n\"description\": \"Running trainers.\",\n\"price\": 130.00,\n},\n],\n},\n{\n\"name\": \"headwear\",\n\"products\": [\n{\n\"title\": \"Cap\",\n\"description\": \"Baseball cap\",\n\"price\": 15.00,\n},\n{\n\"title\": \"Beanie\",\n\"description\": \"Winter running hat.\",\n\"price\": 9.00,\n},\n],\n},\n],\n\"price_cap\": 10,\n}\nproducts = jsonpath.findall(\"$..products.*\", example_data)\nprint(products)\n</code></pre> <p>Which results in a list of all products from all categories:</p> <pre><code>[\n{\n\"title\": \"Trainers\",\n\"description\": \"Fashionable trainers.\",\n\"price\": 89.99\n},\n{\n\"title\": \"Barefoot Trainers\",\n\"description\": \"Running trainers.\",\n\"price\": 130.0\n},\n{\n\"title\": \"Cap\",\n\"description\": \"Baseball cap\",\n\"price\": 15.0\n},\n{\n\"title\": \"Beanie\",\n\"description\": \"Winter running hat.\",\n\"price\": 9.0\n}\n]\n</code></pre> <p>Or, reading data from a JSON formatted file:</p> <pre><code>import jsonpath\nwith open(\"some.json\") as fd:\nproducts = jsonpath.findall(\"$..products.*\", fd)\nprint(products)\n</code></pre> <p>You could use Python JSONPath on data read from a YAML formatted file too, or any data format that can be loaded into dictionaries and lists. If you have PyYAML installed:</p> <pre><code>import jsonpath\nimport yaml\nwith open(\"some.yaml\") as fd:\ndata = yaml.safe_load(fd)\nproducts = jsonpath.findall(\"$..products.*\", data)\nprint(products)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Have a read through the Quick Start and High Level API Reference, or the default JSONPath Syntax supported by Python JSONPath.</p> <p>If you're interested in customizing JSONPath, take a look at Advanced Usage and the Low Level API Reference.</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#filter-variables","title":"Filter Variables","text":"<p>Arbitrary variables can be made available to filter expressions using the filter_context argument to <code>findall()</code> and <code>finditer()</code>. filter_context should be a mapping of strings to JSON-like objects, like lists, dictionaries, strings and integers.</p> <p>Filter context variables are selected using the filter context selector, which defaults to <code>_</code> and has usage similar to <code>$</code> and <code>@</code>.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nuser_names = jsonpath.findall(\n\"$.users[?@.score &lt; _.limit].name\",\ndata,\nfilter_context={\"limit\": 100},\n)\n</code></pre>"},{"location":"advanced/#function-extensions","title":"Function Extensions","text":"<p>Add, remove or replace filter functions by updating the <code>function_extensions</code> attribute of a <code>JSONPathEnvironment</code>. It is a regular Python dictionary mapping filter function names to any callable, like a function or class with a <code>__call__</code> method.</p>"},{"location":"advanced/#type-system-for-function-expressions","title":"Type System for Function Expressions","text":"<p>Section 2.4.1 of the IETF JSONPath Draft specification defines a type system for function expressions and requires that we check that filter expressions are well-typed. With that in mind, you are encouraged to implement custom filter functions by extending <code>jsonpath.function_extensions.FilterFunction</code>, which forces you to be explicit about the types of arguments the function extension accepts and the type of its return value.</p> <p>Info</p> <p><code>FilterFunction</code> was new in Python JSONPath version 0.10.0. Prior to that we did not enforce function expression well-typedness. To use any arbitrary callable as a function extension - or if you don't want built-in filter functions to raise a <code>JSONPathTypeError</code> for function expressions that are not well-typed - set <code>well_typed</code> to <code>False</code> when constructing a <code>JSONPathEnvironment</code>.</p>"},{"location":"advanced/#example","title":"Example","text":"<p>As an example, we'll add a <code>min()</code> filter function, which will return the minimum of a sequence of values. If any of the values are not comparable, we'll return the special <code>undefined</code> value instead.</p> <pre><code>from typing import Iterable\nimport jsonpath\nfrom jsonpath.function_extensions import ExpressionType\nfrom jsonpath.function_extensions import FilterFunction\nclass MinFilterFunction(FilterFunction):\n\"\"\"A JSONPath function extension returning the minimum of a sequence.\"\"\"\narg_types = [ExpressionType.VALUE]\nreturn_type = ExpressionType.VALUE\ndef __call__(self, value: object) -&gt; object:\nif not isinstance(value, Iterable):\nreturn jsonpath.UNDEFINED\ntry:\nreturn min(value)\nexcept TypeError:\nreturn jsonpath.UNDEFINED\nenv = jsonpath.JSONPathEnvironment()\nenv.function_extensions[\"min\"] = MinFilterFunction()\nexample_data = {\"foo\": [{\"bar\": [4, 5]}, {\"bar\": [1, 5]}]}\nprint(env.findall(\"$.foo[?min(@.bar) &gt; 1]\", example_data))\n</code></pre> <p>Now, when we use <code>env.finall()</code>, <code>env.finditer()</code> or <code>env.compile()</code>, our <code>min</code> function will be available for use in filter expressions.</p> <pre><code>$..products[?@.price == min($..products.price)]\n</code></pre>"},{"location":"advanced/#built-in-functions","title":"Built-in Functions","text":"<p>The built-in functions can be removed from a <code>JSONPathEnvironment</code> by deleting the entry from <code>function_extensions</code>.</p> <pre><code>import jsonpath\nenv = jsonpath.JSONPathEnvironment()\ndel env.function_extensions[\"keys\"]\n</code></pre> <p>Or aliased with an additional entry.</p> <pre><code>import jsonpath\nenv = jsonpath.JSONPathEnvironment()\nenv.function_extensions[\"properties\"] = env.function_extensions[\"keys\"]\n</code></pre> <p>Alternatively, you could subclass <code>JSONPathEnvironment</code> and override the <code>setup_function_extensions</code> method.</p> <pre><code>from typing import Iterable\nimport jsonpath\nclass MyEnv(jsonpath.JSONPathEnvironment):\ndef setup_function_extensions(self) -&gt; None:\nsuper().setup_function_extensions()\nself.function_extensions[\"properties\"] = self.function_extensions[\"keys\"]\nself.function_extensions[\"min\"] = min_filter\ndef min_filter(obj: object) -&gt; object:\nif not isinstance(obj, Iterable):\nreturn jsonpath.UNDEFINED\ntry:\nreturn min(obj)\nexcept TypeError:\nreturn jsonpath.UNDEFINED\nenv = MyEnv()\n</code></pre>"},{"location":"advanced/#compile-time-validation","title":"Compile Time Validation","text":"<p>Calls to type-aware function extension are validated at JSONPath compile-time automatically. If <code>well_typed</code> is set to <code>False</code> or a custom function extension does not inherit from <code>FilterFunction</code>, its arguments can be validated by implementing the function as a class with a <code>__call__</code> method, and a <code>validate</code> method. <code>validate</code> will be called after parsing the function, giving you the opportunity to inspect its arguments and raise a <code>JSONPathTypeError</code> should any arguments be unacceptable. If defined, <code>validate</code> must take a reference to the current environment, an argument list and the token pointing to the start of the function call.</p> <pre><code>def validate(\nself,\nenv: JSONPathEnvironment,\nargs: List[FilterExpression],\ntoken: Token,\n) -&gt; List[FilterExpression]:\n</code></pre> <p>It should return an argument list, either the same as the input argument list, or a modified version of it. See the implementation of the built-in <code>match</code> function for an example.</p>"},{"location":"advanced/#custom-environments","title":"Custom Environments","text":"<p>Python JSONPath can be customized by subclassing <code>JSONPathEnvironment</code> and overriding class attributes and/or methods. Then using <code>findall()</code>, <code>finditer()</code> and <code>compile()</code> methods of that subclass.</p>"},{"location":"advanced/#identifier-tokens","title":"Identifier Tokens","text":"<p>The default identifier tokens, like <code>$</code> and <code>@</code>, can be changed by setting attributes a on <code>JSONPathEnvironment</code>. This example sets the root token (default <code>$</code>) to be <code>^</code>.</p> <pre><code>import JSONPathEnvironment\nclass MyJSONPathEnvironment(JSONPathEnvironment):\nroot_token = \"^\"\ndata = {\n\"users\": [\n{\"name\": \"Sue\", \"score\": 100},\n{\"name\": \"John\", \"score\": 86},\n{\"name\": \"Sally\", \"score\": 84},\n{\"name\": \"Jane\", \"score\": 55},\n],\n\"limit\": 100,\n}\nenv = MyJSONPathEnvironment()\nuser_names = env.findall(\n\"^.users[?@.score &lt; ^.limit].name\",\ndata,\n)\n</code></pre> <p>This table shows all available identifier token attributes.</p> attribute default filter_context_token <code>_</code> keys_token <code>#</code> root_token <code>$</code> self_token <code>@</code>"},{"location":"advanced/#logical-operator-tokens","title":"Logical Operator Tokens","text":"<p>TODO:</p>"},{"location":"advanced/#keys-selector","title":"Keys Selector","text":"<p>The non-standard keys selector is used to retrieve the keys/properties from a JSON Object or Python mapping. It defaults to <code>~</code> and can be changed using the <code>keys_selector_token</code> attribute on a <code>JSONPathEnvironment</code> subclass.</p> <p>This example changes the keys selector to <code>*~</code>.</p> <pre><code>from jsonpath import JSONPathEnvironment\nclass MyJSONPathEnvironment(JSONPathEnvironment):\nkeys_selector_token = \"*~\"\ndata = {\n\"users\": [\n{\"name\": \"Sue\", \"score\": 100},\n{\"name\": \"John\", \"score\": 86},\n{\"name\": \"Sally\", \"score\": 84},\n{\"name\": \"Jane\", \"score\": 55},\n],\n\"limit\": 100,\n}\nenv = MyJSONPathEnvironment()\nprint(env.findall(\"$.users[0].*~\", data))  # ['name', 'score']\n</code></pre>"},{"location":"advanced/#array-index-limits","title":"Array Index Limits","text":"<p>Python JSONPath limits the minimum and maximum JSON array or Python sequence indices (including slice steps) allowed in a JSONPath query. The default minimum allowed index is set to <code>-(2**53) + 1</code>, and the maximum to <code>(2**53) - 1</code>. When a limit is reached, a <code>JSONPathIndexError</code> is raised.</p> <p>You can change the minimum and maximum allowed indices using the <code>min_int_index</code> and <code>max_int_index</code> attributes on a <code>JSONPathEnvironment</code> subclass.</p> <pre><code>from jsonpath import JSONPathEnvironment\nclass MyJSONPathEnvironment(JSONPathEnvironment):\nmin_int_index = -100\nmax_int_index = 100\nenv = MyJSONPathEnvironment()\nquery = env.compile(\"$.users[999]\")\n# jsonpath.exceptions.JSONPathIndexError: index out of range, line 1, column 8\n</code></pre>"},{"location":"advanced/#subclassing-lexer","title":"Subclassing Lexer","text":"<p>TODO:</p>"},{"location":"advanced/#subclassing-parser","title":"Subclassing Parser","text":"<p>TODO:</p>"},{"location":"advanced/#get-item","title":"Get Item","text":"<p>TODO:</p>"},{"location":"advanced/#truthiness-and-existence","title":"Truthiness and Existence","text":"<p>TODO:</p>"},{"location":"advanced/#filter-infix-expressions","title":"Filter Infix Expressions","text":"<p>TODO:</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#jsonpath.JSONPathEnvironment","title":"jsonpath.JSONPathEnvironment","text":"<p>JSONPath configuration.</p> <p>This class contains settings for path tokenization, parsing and resolution behavior, plus convenience methods for matching an unparsed path to some data.</p> <p>Most applications will want to create a single <code>JSONPathEnvironment</code>, or use <code>jsonpath.compile()</code>, <code>jsonpath.findall()</code>, etc. from the package-level default environment.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment--environment-customization","title":"Environment customization","text":"<p>Environment customization is achieved by subclassing <code>JSONPathEnvironment</code> and overriding class attributes and/or methods. Some of these customizations include:</p> <ul> <li>Changing the root (<code>$</code>), self (<code>@</code>) or filter context (<code>_</code>) token with   class attributes <code>root_token</code>, <code>self_token</code> and <code>filter_context_token</code>.</li> <li>Registering a custom lexer or parser with the class attributes   <code>lexer_class</code> or <code>parser_class</code>. <code>lexer_class</code> must be a subclass of   <code>Lexer</code> and <code>parser_class</code> must be a subclass of <code>Parser</code>.</li> <li>Setup built-in function extensions by overriding   <code>setup_function_extensions()</code></li> <li>Hook in to mapping and sequence item getting by overriding <code>getitem()</code>.</li> <li>Change filter comparison operator behavior by overriding <code>compare()</code>.</li> </ul>"},{"location":"api/#jsonpath.JSONPathEnvironment--class-attributes","title":"Class attributes","text":"PARAMETER DESCRIPTION <code>filter_caching</code> <p>If <code>True</code>, filter expressions will be cached where possible.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, decode UTF-16 escape sequences found in JSONPath string literals.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>well_typed</code> <p>Control well-typedness checks on filter function expressions. If <code>True</code> (the default), JSONPath expressions are checked for well-typedness as compile time.</p> <p>New in version 0.10.0</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> ATTRIBUTE DESCRIPTION <code>filter_context_token</code> <p>The pattern used to select extra filter context data. Defaults to <code>\"_\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>intersection_token</code> <p>The pattern used as the intersection operator. Defaults to <code>\"&amp;\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>key_token</code> <p>The pattern used to identify the current key or index when filtering a, mapping or sequence. Defaults to <code>\"#\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>keys_selector_token</code> <p>The pattern used as the \"keys\" selector. Defaults to <code>\"~\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>lexer_class</code> <p>The lexer to use when tokenizing path strings.</p> <p> TYPE: <code>Type[Lexer]</code> </p> <code>max_int_index</code> <p>The maximum integer allowed when selecting array items by index. Defaults to <code>(2**53) - 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>min_int_index</code> <p>The minimum integer allowed when selecting array items by index. Defaults to <code>-(2**53) + 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>parser_class</code> <p>The parser to use when parsing tokens from the lexer.</p> <p> TYPE: <code>Type[Parser]</code> </p> <code>root_token</code> <p>The pattern used to select the root node in a JSON document. Defaults to <code>\"$\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>self_token</code> <p>The pattern used to select the current node in a JSON document. Defaults to <code>\"@\"</code></p> <p> TYPE: <code>str</code> </p> <code>union_token</code> <p>The pattern used as the union operator. Defaults to <code>\"|\"</code>.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.filter_caching","title":"filter_caching  <code>instance-attribute</code>","text":"<pre><code>filter_caching: bool = filter_caching\n</code></pre> <p>Enable or disable filter expression caching.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.function_extensions","title":"function_extensions  <code>instance-attribute</code>","text":"<pre><code>function_extensions: Dict[str, Callable[..., Any]] = {}\n</code></pre> <p>A list of function extensions available to filters.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.lexer","title":"lexer  <code>instance-attribute</code>","text":"<pre><code>lexer: Lexer = self.lexer_class(env=self)\n</code></pre> <p>The lexer bound to this environment.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.parser","title":"parser  <code>instance-attribute</code>","text":"<pre><code>parser: Parser = self.parser_class(env=self)\n</code></pre> <p>The parser bound to this environment.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.unicode_escape","title":"unicode_escape  <code>instance-attribute</code>","text":"<pre><code>unicode_escape: bool = unicode_escape\n</code></pre> <p>Enable or disable decoding of UTF-16 escape sequences found in JSONPath string literals.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.well_typed","title":"well_typed  <code>instance-attribute</code>","text":"<pre><code>well_typed: bool = well_typed\n</code></pre> <p>Control well-typedness checks on filter function expressions.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.check_well_typedness","title":"check_well_typedness","text":"<pre><code>check_well_typedness(\ntoken: Token,\nfunc: FilterFunction,\nargs: List[FilterExpression],\n) -&gt; None\n</code></pre> <p>Check the well-typedness of a function's arguments at compile-time.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.compare","title":"compare","text":"<pre><code>compare(left: object, operator: str, right: object) -&gt; bool\n</code></pre> <p>Object comparison within JSONPath filters.</p> <p>Override this to customize filter expression comparison operator behavior.</p> PARAMETER DESCRIPTION <code>left</code> <p>The left hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> <code>operator</code> <p>The comparison expression's operator.</p> <p> TYPE: <code>str</code> </p> <code>right</code> <p>The right hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the comparison between left and right, with the</p> <code>bool</code> <p>given operator, is truthy. <code>False</code> otherwise.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.compile","title":"compile","text":"<pre><code>compile(path: str) -&gt; Union[JSONPath, CompoundJSONPath]\n</code></pre> <p>Prepare a path string ready for repeated matching against different data.</p> PARAMETER DESCRIPTION <code>path</code> <p>A JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Union[JSONPath, CompoundJSONPath]</code> <p>A <code>JSONPath</code> or <code>CompoundJSONPath</code>, ready to match against some data. Expect a <code>CompoundJSONPath</code> if the path string uses the union or intersection operators.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If path is invalid.</p> <code>JSONPathTypeError</code> <p>If filter functions are given arguments of an unacceptable type.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.findall","title":"findall","text":"<pre><code>findall(\npath: str,\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\npath: str,\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.finditer","title":"finditer","text":"<pre><code>finditer(\npath: str,\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\npath: str,\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.getitem","title":"getitem","text":"<pre><code>getitem(obj: Any, key: Any) -&gt; Any\n</code></pre> <p>Sequence and mapping item getter used throughout JSONPath resolution.</p> <p>The default implementation of <code>getitem</code> simply calls <code>operators.getitem()</code> from Python's standard library. Same as <code>obj[key]</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>A mapping or sequence that might contain key.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>A mapping key, sequence index or sequence slice.</p> <p> TYPE: <code>Any</code> </p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.getitem_async","title":"getitem_async  <code>async</code>","text":"<pre><code>getitem_async(obj: Any, key: object) -&gt; Any\n</code></pre> <p>An async sequence and mapping item getter.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.is_truthy","title":"is_truthy","text":"<pre><code>is_truthy(obj: object) -&gt; bool\n</code></pre> <p>Test for truthiness when evaluating JSONPath filter expressions.</p> <p>In some cases, the IETF JSONPath draft requires us to test for existence rather than truthiness. So the default implementation returns <code>True</code> for empty collections and <code>None</code>. The special <code>UNDEFINED</code> object means that obj was missing, as opposed to an explicit <code>None</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>Any object.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the object exists and is not <code>False</code> or <code>0</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.match","title":"match","text":"<pre><code>match(\npath: str,\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Union[JSONPathMatch, None]\n</code></pre> <p>Return a <code>JSONPathMatch</code> instance for the first object found in data.</p> <p><code>None</code> is returned if there are no matches.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[JSONPathMatch, None]</code> <p>A <code>JSONPathMatch</code> object for the first match, or <code>None</code> if there were no matches.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.setup_function_extensions","title":"setup_function_extensions","text":"<pre><code>setup_function_extensions() -&gt; None\n</code></pre> <p>Initialize function extensions.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.validate_function_extension_signature","title":"validate_function_extension_signature","text":"<pre><code>validate_function_extension_signature(\ntoken: Token, args: List[Any]\n) -&gt; List[Any]\n</code></pre> <p>Compile-time validation of function extension arguments.</p> <p>The IETF JSONPath draft requires us to reject paths that use filter functions with too many or too few arguments.</p>"},{"location":"api/#jsonpath.JSONPathMatch","title":"jsonpath.JSONPathMatch","text":"<p>A matched object with a concrete path.</p> ATTRIBUTE DESCRIPTION <code>children</code> <p>Matched child nodes. This will only be populated after all children have been visited, usually by using <code>findall()</code> or <code>list(finditer())</code>.</p> <p> TYPE: <code>List[JSONPathMatch]</code> </p> <code>obj</code> <p>The matched object.</p> <p> TYPE: <code>object</code> </p> <code>parent</code> <p>The immediate parent to this match in the JSON document. If this is the root node, parent will be <code>None</code>.</p> <p> TYPE: <code>Optional[JSONPathMatch]</code> </p> <code>path</code> <p>The canonical string representation of the path to this match.</p> <p> TYPE: <code>str</code> </p> <code>parts</code> <p>The keys, indices and/or slices that make up the path to this match.</p> <p> TYPE: <code>Tuple[PathPart, ...]</code> </p> <code>root</code> <p>A reference to the root node in the JSON document.</p> <p> TYPE: <code>Union[Sequence[Any], Mapping[str, Any]]</code> </p>"},{"location":"api/#jsonpath.match.JSONPathMatch.add_child","title":"add_child","text":"<pre><code>add_child(*children: JSONPathMatch) -&gt; None\n</code></pre> <p>Append one or more children to this match.</p>"},{"location":"api/#jsonpath.match.JSONPathMatch.filter_context","title":"filter_context","text":"<pre><code>filter_context() -&gt; FilterContextVars\n</code></pre> <p>Return filter context data for this match.</p>"},{"location":"api/#jsonpath.match.JSONPathMatch.pointer","title":"pointer","text":"<pre><code>pointer() -&gt; JSONPointer\n</code></pre> <p>Return a <code>JSONPointer</code> pointing to this match's path.</p>"},{"location":"api/#jsonpath.JSONPath","title":"jsonpath.JSONPath","text":"<p>A compiled JSONPath ready to be applied to a JSON string or Python object.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>JSONPathEnvironment</code> this path is bound to.</p> <p> TYPE: <code>JSONPathEnvironment</code> </p> <code>selectors</code> <p>An iterable of <code>JSONPathSelector</code> objects, as generated by a <code>Parser</code>.</p> <p> TYPE: <code>Iterable[JSONPathSelector]</code> </p> ATTRIBUTE DESCRIPTION <code>env</code> <p>The <code>JSONPathEnvironment</code> this path is bound to.</p> <p> </p> <code>selectors</code> <p>The <code>JSONPathSelector</code> instances that make up this path.</p> <p> </p>"},{"location":"api/#jsonpath.path.JSONPath.empty","title":"empty","text":"<pre><code>empty() -&gt; bool\n</code></pre> <p>Return <code>True</code> if this path has no selectors.</p>"},{"location":"api/#jsonpath.path.JSONPath.findall","title":"findall","text":"<pre><code>findall(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will</p> <code>List[object]</code> <p>be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.path.JSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.path.JSONPath.match","title":"match","text":"<pre><code>match(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Union[JSONPathMatch, None]\n</code></pre> <p>Return a <code>JSONPathMatch</code> instance for the first object found in data.</p> <p><code>None</code> is returned if there are no matches.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[JSONPathMatch, None]</code> <p>A <code>JSONPathMatch</code> object for the first match, or <code>None</code> if there were no matches.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.singular_query","title":"singular_query","text":"<pre><code>singular_query() -&gt; bool\n</code></pre> <p>Return <code>True</code> if this JSONPath query is a singular query.</p>"},{"location":"api/#jsonpath.CompoundJSONPath","title":"jsonpath.CompoundJSONPath","text":"<p>Multiple <code>JSONPath</code>s combined.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.findall","title":"findall","text":"<pre><code>findall(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.intersection","title":"intersection","text":"<pre><code>intersection(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>Intersection of this path and another path.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.match","title":"match","text":"<pre><code>match(\ndata: Union[\nstr, IOBase, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Union[JSONPathMatch, None]\n</code></pre> <p>Return a <code>JSONPathMatch</code> instance for the first object found in data.</p> <p><code>None</code> is returned if there are no matches.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[JSONPathMatch, None]</code> <p>A <code>JSONPathMatch</code> object for the first match, or <code>None</code> if there were no matches.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.union","title":"union","text":"<pre><code>union(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>Union of this path and another path.</p>"},{"location":"api/#jsonpath.function_extensions.FilterFunction","title":"jsonpath.function_extensions.FilterFunction","text":"<p>         Bases: <code>ABC</code></p> <p>Base class for typed function extensions.</p>"},{"location":"api/#jsonpath.function_extensions.filter_function.FilterFunction.arg_types","title":"arg_types  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>arg_types: List[ExpressionType]\n</code></pre> <p>Argument types expected by the filter function.</p>"},{"location":"api/#jsonpath.function_extensions.filter_function.FilterFunction.return_type","title":"return_type  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>return_type: ExpressionType\n</code></pre> <p>The type of the value returned by the filter function.</p>"},{"location":"api/#jsonpath.function_extensions.filter_function.FilterFunction.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(*args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Called the filter function.</p>"},{"location":"api/#jsonpath.function_extensions.ExpressionType","title":"jsonpath.function_extensions.ExpressionType","text":"<p>         Bases: <code>Enum</code></p> <p>The type of a filter function argument or return value.</p>"},{"location":"api/#jsonpath.JSONPointer","title":"jsonpath.JSONPointer","text":"<p>Identify a single, specific value in JSON-like data, as per RFC 6901.</p> PARAMETER DESCRIPTION <code>pointer</code> <p>A string representation of a JSON Pointer.</p> <p> TYPE: <code>str</code> </p> <code>parts</code> <p>The keys, indices and/or slices that make up a JSON Pointer. If given, it is assumed that the parts have already been parsed by the JSONPath parser. <code>unicode_escape</code> and <code>uri_decode</code> are ignored if parts is given.</p> <p> TYPE: <code>Tuple[Union[int, str], ...]</code> DEFAULT: <code>()</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> ATTRIBUTE DESCRIPTION <code>keys_selector</code> <p>The non-standard token used to target a mapping key or name.</p> <p> TYPE: <code>str</code> </p> <code>max_int_index</code> <p>The maximum integer allowed when resolving array items by index. Defaults to <code>(2**53) - 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>min_int_index</code> <p>The minimum integer allowed when resolving array items by index. Defaults to <code>-(2**53) + 1</code>.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/#jsonpath.pointer.JSONPointer.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: object) -&gt; JSONPointer\n</code></pre> <p>Join this pointer with other.</p> <p>other is expected to be a JSON Pointer string, possibly without a leading slash. If other does have a leading slash, the previous pointer is ignored and a new JSONPath is returned from other.</p> <p>other should not be a \"Relative JSON Pointer\".</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.exists","title":"exists","text":"<pre><code>exists(\ndata: Union[\nstr, IOBase, Sequence[object], Mapping[str, object]\n]\n) -&gt; bool\n</code></pre> <p>Return True if this pointer can be resolved against data.</p> <p>Note that <code>JSONPointer.resolve()</code> can return legitimate falsy values that form part of the target JSON document. This method will return <code>True</code> if a falsy value is found.</p> PARAMETER DESCRIPTION <code>data</code> <p>The target JSON \"document\" or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[object], Mapping[str, object]]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if this pointer can be resolved against data, or False otherwise.</p> <p>New in version 0.9.0</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.from_match","title":"from_match  <code>classmethod</code>","text":"<pre><code>from_match(match: JSONPathMatch) -&gt; JSONPointer\n</code></pre> <p>Return a JSON Pointer for the path from a JSONPathMatch instance.</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.from_parts","title":"from_parts  <code>classmethod</code>","text":"<pre><code>from_parts(\nparts: Iterable[Union[int, str]],\n*,\nunicode_escape: bool = True,\nuri_decode: bool = False\n) -&gt; JSONPointer\n</code></pre> <p>Build a JSON Pointer from parts.</p> PARAMETER DESCRIPTION <code>parts</code> <p>The keys, indices and/or slices that make up a JSONPointer.</p> <p> TYPE: <code>Iterable[Union[int, str]]</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>JSONPointer</code> <p>A new <code>JSONPointer</code> built from parts.</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.is_relative_to","title":"is_relative_to","text":"<pre><code>is_relative_to(other: JSONPointer) -&gt; bool\n</code></pre> <p>Return True if this pointer points to a child of other.</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.join","title":"join","text":"<pre><code>join(*parts: str) -&gt; JSONPointer\n</code></pre> <p>Join this pointer with parts.</p> <p>Each part is expected to be a JSON Pointer string, possibly without a leading slash. If a part does have a leading slash, the previous pointer is ignored and a new <code>JSONPointer</code> is created, and processing of remaining parts continues.</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.parent","title":"parent","text":"<pre><code>parent() -&gt; JSONPointer\n</code></pre> <p>Return this pointer's parent, as a new <code>JSONPointer</code>.</p> <p>If this pointer points to the document root, self is returned.</p> <p>New in version 0.9.0</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.resolve","title":"resolve","text":"<pre><code>resolve(\ndata: Union[\nstr, IOBase, Sequence[object], Mapping[str, object]\n],\n*,\ndefault: object = UNDEFINED\n) -&gt; object\n</code></pre> <p>Resolve this pointer against data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The target JSON \"document\" or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[object], Mapping[str, object]]</code> </p> <code>default</code> <p>A default value to return if the pointer can't be resolved against the given data.</p> <p> TYPE: <code>object</code> DEFAULT: <code>UNDEFINED</code> </p> RETURNS DESCRIPTION <code>object</code> <p>The object in data pointed to by this pointer.</p> RAISES DESCRIPTION <code>JSONPointerIndexError</code> <p>When attempting to access a sequence by an out of range index, unless a default is given.</p> <code>JSONPointerKeyError</code> <p>If any mapping object along the path does not contain a specified key, unless a default is given.</p> <code>JSONPointerTypeError</code> <p>When attempting to resolve a non-index string path part against a sequence, unless a default is given.</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.resolve_parent","title":"resolve_parent","text":"<pre><code>resolve_parent(\ndata: Union[\nstr, IOBase, Sequence[object], Mapping[str, object]\n]\n) -&gt; Tuple[\nUnion[Sequence[object], Mapping[str, object], None],\nobject,\n]\n</code></pre> <p>Resolve this pointer against data, return the object and its parent.</p> PARAMETER DESCRIPTION <code>data</code> <p>The target JSON \"document\" or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[object], Mapping[str, object]]</code> </p> RETURNS DESCRIPTION <code>Tuple[Union[Sequence[object], Mapping[str, object], None], object]</code> <p>A <code>(parent, object)</code> tuple, where parent will be <code>None</code> if this pointer points to the root node in the document. If the parent exists but the last object does not, <code>(parent, UNDEFINED)</code> will be returned.</p> RAISES DESCRIPTION <code>JSONPointerIndexError</code> <p>When attempting to access a sequence by an out of range index, unless using the special <code>-</code> index.</p> <code>JSONPointerKeyError</code> <p>If any mapping object along the path does not contain a specified key, unless it is the last part of the pointer.</p> <code>JSONPointerTypeError</code> <p>When attempting to resolve a non-index string path part against a sequence.</p>"},{"location":"api/#jsonpath.pointer.JSONPointer.to","title":"to","text":"<pre><code>to(\nrel: Union[RelativeJSONPointer, str],\n*,\nunicode_escape: bool = True,\nuri_decode: bool = False\n) -&gt; JSONPointer\n</code></pre> <p>Return a new pointer relative to this pointer.</p> PARAMETER DESCRIPTION <code>rel</code> <p>A <code>RelativeJSONPointer</code> or a string following \"Relative JSON Pointer\" syntax.</p> <p> TYPE: <code>Union[RelativeJSONPointer, str]</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>See https://www.ietf.org/id/draft-hha-relative-json-pointer-00.html</p>"},{"location":"api/#jsonpath.RelativeJSONPointer","title":"jsonpath.RelativeJSONPointer","text":"<p>A Relative JSON Pointer.</p> <p>See https://www.ietf.org/id/draft-hha-relative-json-pointer-00.html</p> PARAMETER DESCRIPTION <code>rel</code> <p>A string following Relative JSON Pointer syntax.</p> <p> TYPE: <code>str</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/#jsonpath.pointer.RelativeJSONPointer.to","title":"to","text":"<pre><code>to(\npointer: Union[JSONPointer, str],\n*,\nunicode_escape: bool = True,\nuri_decode: bool = False\n) -&gt; JSONPointer\n</code></pre> <p>Return a new JSONPointer relative to pointer.</p> PARAMETER DESCRIPTION <code>pointer</code> <p>A <code>JSONPointer</code> instance or a string following JSON Pointer syntax.</p> <p> TYPE: <code>Union[JSONPointer, str]</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/#jsonpath.JSONPatch","title":"jsonpath.JSONPatch","text":"<p>Modify JSON-like data with JSON Patch.</p> <p>RFC 6902 defines operations to manipulate a JSON document. <code>JSONPatch</code> supports parsing and applying standard JSON Patch formatted operations, and provides a Python builder API following the same semantics as RFC 6902.</p> PARAMETER DESCRIPTION <code>ops</code> <p>A JSON Patch formatted document or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, Iterable[Mapping[str, object]], None]</code> DEFAULT: <code>None</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing JSON pointers.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, JSON pointers will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>JSONPatchError</code> <p>If ops is given and any of the provided operations is malformed.</p>"},{"location":"api/#jsonpath.patch.JSONPatch.add","title":"add","text":"<pre><code>add(path: Union[str, JSONPointer], value: object) -&gt; Self\n</code></pre> <p>Append an add operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>value</code> <p>The object to add.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.patch.JSONPatch.apply","title":"apply","text":"<pre><code>apply(\ndata: Union[\nstr,\nIOBase,\nMutableSequence[object],\nMutableMapping[str, object],\n]\n) -&gt; object\n</code></pre> <p>Apply all operations from this patch to data.</p> <p>If data is a string or file-like object, it will be loaded with json.loads. Otherwise data should be a JSON-like data structure and will be modified in place.</p> <p>When modifying data in place, we return modified data too. This is to allow for replacing data's root element, which is allowed by some patch operations.</p> PARAMETER DESCRIPTION <code>data</code> <p>The target JSON \"document\" or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, MutableSequence[object], MutableMapping[str, object]]</code> </p> RETURNS DESCRIPTION <code>object</code> <p>Modified input data.</p> RAISES DESCRIPTION <code>JSONPatchError</code> <p>When a patch operation fails.</p> <code>JSONPatchTestFailure</code> <p>When a test operation does not pass. <code>JSONPatchTestFailure</code> is a subclass of <code>JSONPatchError</code>.</p>"},{"location":"api/#jsonpath.patch.JSONPatch.asdicts","title":"asdicts","text":"<pre><code>asdicts() -&gt; List[Dict[str, object]]\n</code></pre> <p>Return a list of this patch's operations as dictionaries.</p>"},{"location":"api/#jsonpath.patch.JSONPatch.copy","title":"copy","text":"<pre><code>copy(\nfrom_: Union[str, JSONPointer],\npath: Union[str, JSONPointer],\n) -&gt; Self\n</code></pre> <p>Append a copy operation to this patch.</p> PARAMETER DESCRIPTION <code>from_</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.patch.JSONPatch.move","title":"move","text":"<pre><code>move(\nfrom_: Union[str, JSONPointer],\npath: Union[str, JSONPointer],\n) -&gt; Self\n</code></pre> <p>Append a move operation to this patch.</p> PARAMETER DESCRIPTION <code>from_</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.patch.JSONPatch.remove","title":"remove","text":"<pre><code>remove(path: Union[str, JSONPointer]) -&gt; Self\n</code></pre> <p>Append a remove operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.patch.JSONPatch.replace","title":"replace","text":"<pre><code>replace(\npath: Union[str, JSONPointer], value: object\n) -&gt; Self\n</code></pre> <p>Append a replace operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>value</code> <p>The object to add.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.patch.JSONPatch.test","title":"test","text":"<pre><code>test(path: Union[str, JSONPointer], value: object) -&gt; Self\n</code></pre> <p>Append a test operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>value</code> <p>The object to test.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"async/","title":"Async API","text":"<p>Largely motivated by its integration with Python Liquid, Python JSONPath offers an asynchronous API that allows for items in a target data structure to be \"fetched\" lazily.</p> <p><code>findall_async()</code> and <code>finditer_async()</code> are asyncio equivalents to <code>findall()</code> and <code>finditer()</code>. By default, any class implementing the mapping or sequence interfaces, and a <code>__getitem_async__()</code> method, will have <code>__getitem_async__()</code> awaited instead of calling <code>__getitem__()</code> when resolving mapping keys or sequence indices.</p>"},{"location":"async/#example","title":"Example","text":"<p>In this example, showing a lazy-loading collections of <code>Player</code> objects, only the \"A\" team's players are fetched from the database, and only when they are first accessed.</p> <pre><code>from collections import abc\nfrom dataclasses import dataclass\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nimport jsonpath\n@dataclass\nclass Player:\nname: str\npid: int\nrank: int\nclass LazyPlayers(abc.Mapping[str, Player]):\ndef __init__(self, names: List[str]):\nself.names = names\nself.cached_players: Dict[str, Player] = {}\ndef __len__(self) -&gt; int:\nreturn len(self.names)\ndef __iter__(self) -&gt; Iterator[str]:\nreturn iter(self.names)\ndef __getitem__(self, k: str) -&gt; Player:\nif self.cached_players is None:\n# Blocking IO here\nself.cached_players = get_stuff_from_database()\nreturn self.cached_players[k]\nasync def __getitem_async__(self, k: str) -&gt; Player:\nif self.cached_players is None:\n# Do async IO here.\nself.cached_players = await get_stuff_from_database_async()\nreturn self.cached_players[k]\ndata = {\n\"teams\": {\n\"A Team\": LazyPlayers([\"Sue\", \"Bob\"]),\n\"B Team\": LazyPlayers([\"Sally\", \"Frank\"]),\n}\n}\nbest_a_team_players = jsonpath.findall_async(\"$.teams['A Team'][?rank &gt;= 8]\", data)\n</code></pre>"},{"location":"async/#custom-async-item-getting","title":"Custom Async Item Getting","text":"<p>TODO:</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p>New in version 0.9.0</p> <p>Python JSONPath includes a script called <code>json</code>, exposing JSONPath, JSON Pointer and JSON Patch features on the command line. Use the <code>--version</code> argument to check the current version of Python JSONPath, and the <code>--help</code> argument to display command information.</p> <pre><code>$ json --version\npython-jsonpath, version 0.9.0\n</code></pre> <pre><code>$ json --help\nusage: json [-h] [--debug] [--pretty] [-v] [--no-unicode-escape] COMMAND ...\nJSONPath, JSON Pointer and JSON Patch utilities.\npositional arguments:\n  COMMAND\n    path               Find objects in a JSON document given a JSONPath.\n    pointer            Resolve a JSON Pointer against a JSON document.\n    patch              Apply a JSON Patch to a JSON document.\noptional arguments:\n  -h, --help           show this help message and exit\n  --debug              Show stack traces. (default: False)\n  --pretty             Add indents and newlines to output JSON. (default: False)\n  -v, --version        Show the version and exit.\n  --no-unicode-escape  Disable decoding of UTF-16 escape sequence within paths and pointers. (default:\n                       False)\nUse [json COMMAND --help] for command specific help.\nUsage Examples:\n  Find objects in source.json matching a JSONPath, write them to result.json.\n  $ json path -q \"$.foo['bar'][?@.baz &gt; 1]\" -f source.json -o result.json\n\n  Resolve a JSON Pointer against source.json, pretty print the result to stdout.\n  $ json --pretty pointer -p \"/foo/bar/0\" -f source.json\n\n  Apply JSON Patch patch.json to JSON from stdin, output to result.json.\n  $ cat source.json | json patch /path/to/patch.json -o result.json\n</code></pre> <p>Use <code>json COMMAND --help</code> for command specific help.</p> <pre><code>$ json path --help\nusage: json path [-h] (-q QUERY | -r PATH_FILE) [-f FILE] [-o OUTPUT]\nFind objects in a JSON document given a JSONPath.\noptional arguments:\n  -h, --help            show this help message and exit\n  -q QUERY, --query QUERY\n                        JSONPath query string.\n  -r PATH_FILE, --path-file PATH_FILE\n                        Text file containing a JSONPath query.\n  -f FILE, --file FILE  File to read the target JSON document from. Defaults to reading from the\n                        standard input stream.\n  -o OUTPUT, --output OUTPUT\n                        File to write resulting objects to, as a JSON array. Defaults to the standard\n                        output stream.\n  --no-type-checks      Disables filter expression well-typedness checks.\n</code></pre>"},{"location":"cli/#global-options","title":"Global Options","text":"<p>These arguments apply to any subcommand and must be listed before the command.</p>"},{"location":"cli/#-debug","title":"<code>--debug</code>","text":"<p>Enable debugging. Display full stack traces, if available, when errors occur. Without the <code>--debug</code> option, the following example shows a short \"json path syntax error\" message.</p> <pre><code>$ json path -q \"$.1\" -f /tmp/source.json\njson path syntax error: unexpected token '1', line 1, column 2\n</code></pre> <p>With the <code>--debug</code> option, we get the stack trace triggered by <code>JSONPathSyntaxError</code>.</p> <pre><code>$ json --debug path -q \"$.1\" -f /tmp/source.json\nTraceback (most recent call last):\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/bin/json\", line 8, in &lt;module&gt;\n    sys.exit(main())\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/cli.py\", line 338, in main\n    args.func(args)\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/cli.py\", line 234, in handle_path_command\n    path = jsonpath.compile(args.query or args.path_file.read())\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/env.py\", line 148, in compile\n    _path: Union[JSONPath, CompoundJSONPath] = JSONPath(\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/path.py\", line 49, in __init__\n    self.selectors = tuple(selectors)\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/parse.py\", line 256, in parse\n    raise JSONPathSyntaxError(\njsonpath.exceptions.JSONPathSyntaxError: unexpected token '1', line 1, column 2\n</code></pre>"},{"location":"cli/#-pretty","title":"<code>--pretty</code>","text":"<p>Enable pretty formatting when outputting JSON. Adds newlines and indentation to output specified with the <code>-o</code> or <code>--output</code> option. Without the <code>--pretty</code> option, the following example output is on one line.</p> <pre><code>$ json pointer -p \"/categories/1/products/0\" -f /tmp/source.json\n{\"title\": \"Cap\", \"description\": \"Baseball cap\", \"price\": 15.0}\n</code></pre> <p>With the <code>--pretty</code> option, we get nicely formatted JSON output.</p> <pre><code>$ json --pretty pointer -p \"/categories/1/products/0\" -f /tmp/source.json\n{\n  \"title\": \"Cap\",\n  \"description\": \"Baseball cap\",\n  \"price\": 15.0\n}\n</code></pre>"},{"location":"cli/#-no-unicode-escape","title":"<code>--no-unicode-escape</code>","text":"<p>Disable decoding of UTF-16 escape sequences, including surrogate paris. This can improve performance if you know your paths and pointers don't contain UTF-16 escape sequences.</p> <pre><code>$ json --no-unicode-escape path -q \"$.price_cap\" -f /tmp/source.json\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":"<p>One of the subcommands <code>path</code>, <code>pointer</code> or <code>patch</code> must be specified, depending on whether you want to search a JSON document with a JSONPath, resolve a JSON Pointer against a JSON document or apply a JSON Patch to a JSON Document.</p>"},{"location":"cli/#path","title":"<code>path</code>","text":"<p>Find objects in a JSON document given a JSONPath. One of <code>-q</code>/<code>--query</code> or <code>-r</code>/<code>--path-file</code> must be given. <code>-q</code> being a JSONPath given on the command line as a string, <code>-r</code> being the path to a file containing a JSONPath.</p> <pre><code>json path [-h] (-q QUERY | -r PATH_FILE) [-f FILE] [-o OUTPUT]\n</code></pre>"},{"location":"cli/#-q-query","title":"<code>-q</code> / <code>--query</code>","text":"<p>The JSONPath as a string.</p> <pre><code>$ json path -q \"$.price_cap\" -f /tmp/source.json\n</code></pre> <pre><code>$ json path --query \"$.price_cap\" -f /tmp/source.json\n</code></pre>"},{"location":"cli/#-r-path-file","title":"<code>-r</code> / <code>--path-file</code>","text":"<p>The path to a file containing a JSONPath.</p> <pre><code>$ json path -r /tmp/path.txt -f /tmp/source.json\n</code></pre> <pre><code>$ json path --path-file /tmp/path.txt -f /tmp/source.json\n</code></pre>"},{"location":"cli/#-f-file","title":"<code>-f</code> / <code>--file</code>","text":"<p>The path to a file containing the target JSON document. If omitted or a hyphen (<code>-</code>), the target JSON document will be read from the standard input stream.</p> <pre><code>$ json path -q \"$.price_cap\" -f /tmp/source.json\n</code></pre> <pre><code>$ json path -q \"$.price_cap\" --file /tmp/source.json\n</code></pre>"},{"location":"cli/#-o-output","title":"<code>-o</code> / <code>--output</code>","text":"<p>The path to a file to write resulting objects to, as a JSON array. If omitted or a hyphen (<code>-</code>) is given, results will be written to the standard output stream.</p> <pre><code>$ json path -q \"$.price_cap\" -f /tmp/source.json -o result.json\n</code></pre> <pre><code>$ json path -q \"$.price_cap\" -f /tmp/source.json --output result.json\n</code></pre>"},{"location":"cli/#-no-type-checks","title":"<code>--no-type-checks</code>","text":"<p>New in version 0.10.0</p> <p>Disables JSONPath filter expression well-typedness checks. The well-typedness of a filter expression is defined by the IETF JSONPath Draft specification.</p>"},{"location":"cli/#pointer","title":"<code>pointer</code>","text":"<p>Resolve a JSON Pointer against a JSON document. One of <code>-p</code>/<code>--pointer</code> or <code>-r</code>/<code>--pointer-file</code> must be given. <code>-p</code> being a JSON Pointer given on the command line as a string, <code>-r</code> being the path to a file containing a JSON Pointer.</p> <pre><code>json pointer [-h] (-p POINTER | -r POINTER_FILE) [-f FILE] [-o OUTPUT] [-u]\n</code></pre>"},{"location":"cli/#-p-pointer","title":"<code>-p</code> / <code>--pointer</code>","text":"<p>An RFC 6901 formatted JSON Pointer string.</p> <pre><code>$ json pointer -p \"/categories/0/name\" -f /tmp/source.json\n</code></pre> <pre><code>$ json pointer --pointer \"/categories/0/name\" -f /tmp/source.json\n</code></pre>"},{"location":"cli/#-r-pointer-file","title":"<code>-r</code> / <code>--pointer-file</code>","text":"<p>The path to a file containing a JSON Pointer.</p> <pre><code>$ json pointer -r /tmp/pointer.txt -f /tmp/source.json\n</code></pre> <pre><code>$ json pointer --pointer-file /tmp/pointer.txt -f /tmp/source.json\n</code></pre>"},{"location":"cli/#-f-file_1","title":"<code>-f</code> / <code>--file</code>","text":"<p>The path to a file containing the target JSON document. If omitted or a hyphen (<code>-</code>), the target JSON document will be read from the standard input stream.</p> <pre><code>$ json pointer -p \"/categories/0/name\" -f /tmp/source.json\n</code></pre> <pre><code>$ json pointer -p \"/categories/0/name\" --file /tmp/source.json\n</code></pre>"},{"location":"cli/#-o-output_1","title":"<code>-o</code> / <code>--output</code>","text":"<p>The path to a file to write the resulting object to. If omitted or a hyphen (<code>-</code>) is given, results will be written to the standard output stream.</p> <pre><code>$ json pointer -p \"/categories/0/name\" -f /tmp/source.json -o result.json\n</code></pre> <pre><code>$ json pointer -p \"/categories/0/name\" -f /tmp/source.json --output result.json\n</code></pre>"},{"location":"cli/#-u-uri-decode","title":"<code>-u</code> / <code>--uri-decode</code>","text":"<p>Enable URI decoding of the JSON Pointer. In this example, we would look for a property called \"hello world\" in the root of the target document.</p> <pre><code>$ json pointer -p \"/hello%20world\" -f /tmp/source.json -u\n</code></pre> <pre><code>$ json pointer -p \"/hello%20world\" -f /tmp/source.json --uri-decode\n</code></pre>"},{"location":"cli/#patch","title":"<code>patch</code>","text":"<p>Apply a JSON Patch to a JSON document. Unlike <code>path</code> and <code>pointer</code> commands, a patch can't be given as a string argument. <code>PATCH</code> is a positional argument that should be a file path to a JSON Patch document or a hyphen (<code>-</code>), which means the patch document will be read from the standard input stream.</p> <pre><code>json patch [-h] [-f FILE] [-o OUTPUT] [-u] PATCH\n</code></pre> <p>These examples read the patch from <code>patch.json</code> and the document to modify from <code>target.json</code></p> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json\n</code></pre> <pre><code>$ cat /tmp/patch.json | json patch - -f /tmp/target.json\n</code></pre>"},{"location":"cli/#-f-file_2","title":"<code>-f</code> / <code>--file</code>","text":"<p>The path to a file containing the target JSON document. If omitted or a hyphen (<code>-</code>), the target JSON document will be read from the standard input stream.</p> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json\n</code></pre> <pre><code>$ json patch /tmp/patch.json --file /tmp/target.json\n</code></pre>"},{"location":"cli/#-o-output_2","title":"<code>-o</code> / <code>--output</code>","text":"<p>The path to a file to write the resulting object to. If omitted or a hyphen (<code>-</code>) is given, results will be written to the standard output stream.</p> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json -o result.json\n</code></pre> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json --output result.json\n</code></pre>"},{"location":"cli/#-u-uri-decode_1","title":"<code>-u</code> / <code>--uri-decode</code>","text":"<p>Enable URI decoding of JSON Pointers in the patch document.</p> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json -u\n</code></pre> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json --uri-decode\n</code></pre>"},{"location":"custom_api/","title":"Low Level API Reference","text":""},{"location":"custom_api/#jsonpath.token.Token","title":"jsonpath.token.Token","text":"<p>A token, as returned from <code>lex.Lexer.tokenize()</code>.</p> ATTRIBUTE DESCRIPTION <code>kind</code> <p>The token's type. It is always one of the constants defined in jsonpath.token.py.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The path substring containing text for the token.</p> <p> TYPE: <code>str</code> </p> <code>index</code> <p>The index at which value starts in path.</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>A reference to the complete JSONPath string from which this token derives.</p> <p> TYPE: <code>str</code> </p>"},{"location":"custom_api/#jsonpath.token.Token.position","title":"position","text":"<pre><code>position() -&gt; Tuple[int, int]\n</code></pre> <p>Return the line and column number for the start of this token.</p>"},{"location":"custom_api/#jsonpath.filter.FilterExpression","title":"jsonpath.filter.FilterExpression","text":"<p>         Bases: <code>ABC</code></p> <p>Base class for all filter expression nodes.</p>"},{"location":"custom_api/#jsonpath.filter.FilterExpression.children","title":"children  <code>abstractmethod</code>","text":"<pre><code>children() -&gt; List[FilterExpression]\n</code></pre> <p>Return a list of direct child expressions.</p>"},{"location":"custom_api/#jsonpath.filter.FilterExpression.evaluate","title":"evaluate  <code>abstractmethod</code>","text":"<pre><code>evaluate(context: FilterContext) -&gt; object\n</code></pre> <p>Resolve the filter expression in the given context.</p> PARAMETER DESCRIPTION <code>context</code> <p>Contextual information the expression might choose use during evaluation.</p> <p> TYPE: <code>FilterContext</code> </p> RETURNS DESCRIPTION <code>object</code> <p>The result of evaluating the expression.</p>"},{"location":"custom_api/#jsonpath.filter.FilterExpression.evaluate_async","title":"evaluate_async  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>evaluate_async(context: FilterContext) -&gt; object\n</code></pre> <p>An async version of <code>evaluate</code>.</p>"},{"location":"custom_api/#jsonpath.filter.FilterExpression.set_children","title":"set_children  <code>abstractmethod</code>","text":"<pre><code>set_children(children: List[FilterExpression]) -&gt; None\n</code></pre> <p>Update this expression's child expressions.</p> <p>children is assumed to have the same number of items as is returned by self.children, and in the same order.</p>"},{"location":"custom_api/#jsonpathlexlexer","title":"jsonpath.lex.Lexer","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathparseparser","title":"jsonpath.parse.Parser","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathselectorsjsonpathselector","title":"jsonpath.selectors.JSONPathSelector","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathstreamtokenstream","title":"jsonpath.stream.TokenStream","text":"<p>TODO:</p>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Each of the following exceptions has a <code>token</code> property, referencing the <code>Token</code> that caused the error. You can use <code>Token.position()</code> to get the token's line and column number.</p>"},{"location":"exceptions/#jsonpath.JSONPathError","title":"jsonpath.JSONPathError","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for all errors.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Optional[Token]</code> DEFAULT: <code>None</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathSyntaxError","title":"jsonpath.JSONPathSyntaxError","text":"<p>         Bases: <code>JSONPathError</code></p> <p>An exception raised when parsing a JSONPath string.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathTypeError","title":"jsonpath.JSONPathTypeError","text":"<p>         Bases: <code>JSONPathError</code></p> <p>An exception raised due to a type error.</p> <p>This should only occur at when evaluating filter expressions.</p>"},{"location":"exceptions/#jsonpath.JSONPathIndexError","title":"jsonpath.JSONPathIndexError","text":"<p>         Bases: <code>JSONPathError</code></p> <p>An exception raised when an array index is out of range.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathNameError","title":"jsonpath.JSONPathNameError","text":"<p>         Bases: <code>JSONPathError</code></p> <p>An exception raised when an unknown function extension is called.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"functions/","title":"Filter Functions","text":"<p>A filter function is a named function that can be called as part of a filter selector expression. Here we describe built-in filters. You can define your own function extensions too.</p>"},{"location":"functions/#count","title":"<code>count()</code>","text":"<pre><code>count(obj: object) -&gt; Optional[int]\n</code></pre> <p>Return the number of items in obj. If the object does not respond to Python's <code>len()</code> function, <code>None</code> is returned.</p> <pre><code>$.categories[?count(@.products.*) &gt;= 2]\n</code></pre>"},{"location":"functions/#isinstance","title":"<code>isinstance()</code>","text":"<p>New in version 0.6.0</p> <pre><code>isinstance(obj: object, t: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the type of obj matches t. This function allows t to be one of several aliases for the real Python \"type\". Some of these aliases follow JavaScript/JSON semantics.</p> type aliases UNDEFINED \"undefined\", \"missing\" None \"null\", \"nil\", \"None\", \"none\" str \"str\", \"string\" Sequence (array-like) \"array\", \"list\", \"sequence\", \"tuple\" Mapping (dict-like) \"object\", \"dict\", \"mapping\" bool \"bool\", \"boolean\" int \"number\", \"int\" float \"number\", \"float\" <p>For example :</p> <pre><code>$.categories[?isinstance(@.length, 'number')]\n</code></pre> <p>And <code>is()</code> is an alias for <code>isinstance()</code>:</p> <pre><code>$.categories[?is(@.length, 'number')]\n</code></pre>"},{"location":"functions/#length","title":"<code>length()</code>","text":"<pre><code>length(obj: object) -&gt; Optional[int]\n</code></pre> <p>Return the number of items in the input object. If the object does not respond to Python's <code>len()</code> function, <code>None</code> is returned.</p> <pre><code>$.categories[?length(@) &gt; 1]\n</code></pre>"},{"location":"functions/#match","title":"<code>match()</code>","text":"<pre><code>match(obj: object, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if obj is a string and is a full match to the regex pattern.</p> <pre><code>$..products[?match(@.title, \".+ainers.+\")]\n</code></pre> <p>If pattern is a string literal, it will be compiled at compile time, and raise a <code>JSONPathTypeError</code> at compile time if it's invalid.</p> <p>If pattern is a query and the result is not a valid regex, <code>False</code> is returned.</p>"},{"location":"functions/#search","title":"<code>search()</code>","text":"<pre><code>search(obj: object, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if obj is a string and it contains the regexp pattern.</p> <pre><code>$..products[?search(@.title, \"ainers\")]\n</code></pre> <p>If pattern is a string literal, it will be compiled at compile time, and raise a <code>JSONPathTypeError</code> at compile time if it's invalid.</p> <p>If pattern is a query and the result is not a valid regex, <code>False</code> is returned.</p>"},{"location":"functions/#typeof","title":"<code>typeof()</code>","text":"<p>New in version 0.6.0</p> <pre><code>typeof(obj: object) -&gt; str\n</code></pre> <p>Return the type of obj as a string. The strings returned from this function use JavaScript/JSON terminology like \"string\", \"array\" and \"object\", much like the result of JavaScript's <code>typeof</code> operator.</p> <pre><code>$.categories[?typeof(@.length) == 'number']\n</code></pre> <p><code>type()</code> is and alias for <code>typeof()</code>.</p> <p><code>jsonpath.function_extensions.TypeOf</code> takes a <code>single_number_type</code> argument, which controls the behavior of <code>typeof()</code> when given and int or float. By default, <code>single_number_type</code> is <code>True</code> and <code>\"number\"</code> is returned. Register a new instance of <code>TypeOf</code> with a <code>JSONPathEnvironment</code> with <code>single_number_type</code> set to <code>False</code> and <code>\"int\"</code> and <code>\"float\"</code> will be returned when given integers and floats, respectively.</p> instance type string UNDEFINED \"undefined\" None \"null\" str \"string\" Sequence (array-like) \"array\" Mapping (dict-like) \"object\" bool \"boolean\" int \"number\" or \"int\" if <code>single_number_type</code> is <code>False</code> float \"number\" or \"float\" if <code>single_number_type</code> is <code>False</code>"},{"location":"functions/#value","title":"<code>value()</code>","text":"<pre><code>value(nodes: object) -&gt; object | undefined\n</code></pre> <p>Return the first value from nodes resulting from a JSONPath query, if there is only one node, or <code>undefined</code> otherwise.</p> <pre><code>$..products[?value(@.price) == 9]\n</code></pre>"},{"location":"pointers/","title":"JSON Pointers","text":"<p>New in version 0.8.0</p> <p>JSON Pointer (RFC 6901) is a string syntax for targeting a single value (JSON object, array or scalar) in a JSON document. Whereas a JSONPath has the potential to yield many values from a JSON document, a JSON Pointer can resolve to at most one value.</p> <p>JSON Pointers are a fundamental part of JSON Patch (RFC 6902). Each patch operation must have at least one pointer, identifying the target value.</p> <p>Note</p> <p>We have extended RFC 6901 to handle our non-standard JSONPath keys selector and index/property pointers from Relative JSON Pointer.</p>"},{"location":"pointers/#resolvedata","title":"<code>resolve(data)</code>","text":"<p>Resolve this pointer against data. data can be a file-like object or string containing JSON formatted data, or a Python <code>Mapping</code> or <code>Sequence</code>, like a dictionary or list.</p> <pre><code>from jsonpath import JSONPointer\nexample_data = {\"foo\": {\"bar\": [1, 2, 3]}}\npointer = JSONPointer(\"/foo/bar/0\")\nprint(pointer.resolve(example_data))  # 1\n</code></pre>"},{"location":"pointers/#resolve_parentdata","title":"<code>resolve_parent(data)</code>","text":"<p>Resolve this pointer against data, return the object and its parent as a <code>(parent, object)</code> tuple.</p> <p>If object does not exist in data but parent does, <code>(parent, UNDEFINED)</code> will be returned. Where <code>jsonpath.pointer.UNDEFINED</code> indicates the lack of a value.</p> <p>If this pointer points to the JSON document root, parent will be <code>None</code>.</p> <pre><code>from jsonpath import JSONPointer\nexample_data = {\"foo\": {\"bar\": [1, 2, 3]}}\npointer = JSONPointer(\"/foo/bar/0\")\nprint(pointer.resolve_parent(example_data))  # ([1, 2, 3], 1)\n# 'thing' does not exist\npointer = JSONPointer(\"/foo/thing\")\nprint(pointer.resolve_parent(example_data))  # ({'bar': [1, 2, 3]}, &lt;jsonpath.pointer._Undefined object at 0x7f0c7cf77040&gt;)\npointer = JSONPointer(\"\")\nprint(pointer.resolve_parent(example_data))  # (None, {'foo': {'bar': [1, 2, 3]}})\n</code></pre>"},{"location":"pointers/#existsdata","title":"<code>exists(data)</code>","text":"<p>New in version 0.9.0</p> <p>Return True if this pointer can be resolved against data, or False otherwise. Note that <code>JSONPointer.resolve()</code> can return legitimate falsy values that form part of the target JSON document. This method will return <code>True</code> if a falsy value is found.</p> <pre><code>from jsonpath import JSONPointer\nexample_data = {\"foo\": {\"bar\": [1, 2, 3]}, \"baz\": False}\npointer = JSONPointer(\"/foo/bar/0\")\nprint(pointer.exists(example_data))  # True\npointer = JSONPointer(\"/foo/bar/9\")\nprint(pointer.exists(example_data))  # False\npointer = JSONPointer(\"/baz\")\nprint(pointer.exists(example_data))  # True\n</code></pre>"},{"location":"pointers/#joinparts","title":"<code>join(*parts)</code>","text":"<p>New in version 0.9.0</p> <p>Join this pointer with parts. Each part is expected to be a JSON Pointer string, possibly without a leading slash. If a part does have a leading slash, the previous pointer is ignored and a new <code>JSONPointer</code> is created, and processing of remaining parts continues.</p> <p><code>join()</code> is equivalent to using the slash (<code>/</code>) operator for each argument.</p> <pre><code>from jsonpath import JSONPointer\npointer = JSONPointer(\"/foo/bar\")\nprint(pointer)  # /foo/bar\nprint(pointer.join(\"baz\"))  # /foo/bar/baz\nprint(pointer.join(\"baz\", \"0\"))  # /foo/bar/baz/0\n</code></pre>"},{"location":"pointers/#parent","title":"<code>parent()</code>","text":"<p>New in version 0.9.0</p> <p>Return this pointer's parent as a new <code>JSONPointer</code>. If this pointer points to the document root, self is returned.</p> <pre><code>from jsonpath import JSONPointer\npointer = JSONPointer(\"/foo/bar\")\nprint(pointer)  # /foo/bar\nprint(pointer.parent())  # /foo\n</code></pre>"},{"location":"pointers/#is_relative_topointer","title":"<code>is_relative_to(pointer)</code>","text":"<p>Return True if this pointer points to a child of the argument pointer, which must be a <code>JSONPointer</code> instance.</p> <pre><code>from jsonpath import JSONPointer\npointer = JSONPointer(\"/foo/bar\")\nanother_pointer = JSONPointer(\"/foo/bar/0\")\nprint(another_pointer.is_relative_to(pointer))  # True\nanother_pointer = JSONPointer(\"/foo/baz\")\nprint(another_pointer.is_relative_to(pointer))  # False\n</code></pre>"},{"location":"pointers/#torel","title":"<code>to(rel)</code>","text":"<p>New in version 0.9.0</p> <p>Return a new <code>JSONPointer</code> relative to this pointer. rel should be a <code>RelativeJSONPointer</code> instance or a string following Relative JSON Pointer syntax.</p> <pre><code>from jsonpath import JSONPointer\ndata = {\"foo\": {\"bar\": [1, 2, 3], \"baz\": [4, 5, 6]}}\npointer = JSONPointer(\"/foo/bar/2\")\nprint(pointer.resolve(data))  # 3\nprint(pointer.to(\"0-1\").resolve(data))  # 2\nprint(pointer.to(\"2/baz/2\").resolve(data))  # 6\n</code></pre> <p>A <code>RelativeJSONPointer</code> can be instantiated for repeated application to multiple different pointers.</p> <pre><code>from jsonpath import JSONPointer\nfrom jsonpath import RelativeJSONPointer\ndata = {\"foo\": {\"bar\": [1, 2, 3], \"baz\": [4, 5, 6], \"some\": \"thing\"}}\nsome_pointer = JSONPointer(\"/foo/bar/0\")\nanother_pointer = JSONPointer(\"/foo/baz/2\")\nrel = RelativeJSONPointer(\"2/some\")\nprint(rel.to(some_pointer).resolve(data))  # thing\nprint(rel.to(another_pointer).resolve(data))  # thing\n</code></pre>"},{"location":"pointers/#slash-operator","title":"Slash Operator","text":"<p>New in version 0.9.0</p> <p>The slash operator allows you to create pointers that are children of an existing pointer.</p> <pre><code>from jsonpath import JSONPointer\npointer = JSONPointer(\"/users\")\nchild_pointer = pointer / \"score\" / \"0\"\nanother_child_pointer = pointer / \"score/1\"\nprint(child_pointer)  # \"/users/score/0\"\nprint(another_child_pointer)  # \"/users/score/1\"\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This page gets you started using JSONPath, JSON Pointer and JSON Patch wih Python. See JSONPath Syntax for information on JSONPath selector syntax.</p>"},{"location":"quickstart/#findallpath-data","title":"<code>findall(path, data)</code>","text":"<p>Find all objects matching a JSONPath with <code>jsonpath.findall()</code>. It takes, as arguments, a JSONPath string and some data object. It always returns a list of objects selected from data, never a scalar value.</p> <p>data can be a file-like object or string containing JSON formatted data, or a Python <code>Mapping</code> or <code>Sequence</code>, like a dictionary or list. In this example we select user names from a dictionary containing a list of user dictionaries.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nuser_names = jsonpath.findall(\"$.users.*.name\", data)\n</code></pre> <p>Where <code>user_names</code> is now equal to:</p> <pre><code>[\"Sue\", \"John\", \"Sally\", \"Jane\"]\n</code></pre> <p>If the same data were in a file called <code>users.json</code>, we might use <code>findall()</code> like this:</p> <pre><code>import jsonpath\nwith open(\"users.json\") as fd:\nuser_names = jsonpath.findall(\"$.users.*.name\", fd)\n</code></pre>"},{"location":"quickstart/#finditerpath-data","title":"<code>finditer(path, data)</code>","text":"<p>Use <code>jsonpath.finditer()</code> to iterate over instances of <code>jsonpath.JSONPathMatch</code> for every object in data that matches path. It accepts the same arguments as <code>findall()</code>, a path string and data from which to select matches.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nmatches = jsonpath.finditer(\"$.users.*.name\", data)\nfor match in matches:\nprint(matches)\n</code></pre> <p>The string representation of a <code>JSONPathMatch</code> shows the matched object and the canonical path to that object.</p> <pre><code>'Sue' @ $['users'][0]['name']\n'John' @ $['users'][1]['name']\n'Sally' @ $['users'][2]['name']\n'Jane' @ $['users'][3]['name']\n</code></pre> <p>The selected object is available from a <code>JSONPathMatch</code> as <code>obj</code> and its path, as a string, as <code>path</code>. Other useful properties of <code>JSONPathMatch</code> include a reference to the parent match, a list of child matches, and a <code>parts</code> tuple of keys and indices that make up the path.</p>"},{"location":"quickstart/#compilepath","title":"<code>compile(path)</code>","text":"<p>When you have a JSONPath that needs to be matched against different data repeatedly, you can compile the path ahead of time using <code>jsonpath.compile()</code>. It takes a path as a string and returns a <code>JSONPath</code> instance. <code>JSONPath</code> has <code>findall()</code> and <code>finditer()</code> methods that behave similarly to package-level <code>findall()</code> and <code>finditer()</code>, just without the <code>path</code> argument.</p> <pre><code>import jsonpath\nsome_data = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n]\n}\nother_data = {\n\"users\": [\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\npath = jsonpath.compile(\"$.users.*.name\")\nsome_users = path.findall(some_data)\nother_users = path.findall(other_data)\n</code></pre>"},{"location":"quickstart/#matchpath-data","title":"<code>match(path, data)</code>","text":"<p>New in version 0.8.0</p> <p>Get a <code>jsonpath.JSONPathMatch</code> instance for the first match found in data. If there are no matches, <code>None</code> is returned. <code>match()</code> accepts the same arguments as <code>findall()</code>.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nmatch = jsonpath.match(\"$.users[?@.score &gt; 85].name\", data)\nif match:\nprint(match)  # 'Sue' @ $['users'][0]['name']\nprint(match.obj)  # Sue\n</code></pre>"},{"location":"quickstart/#pointerresolvepointer-data","title":"<code>pointer.resolve(pointer, data)</code>","text":"<p>New in version 0.8.0</p> <p>Resolve a JSON Pointer (RFC 6901) against some data. A JSON Pointer references a single object on a specific \"path\" in a JSON document. Here, pointer can be a string representation of a JSON Pointer or a list of parts that make up a pointer. data can be a file-like object or string containing JSON formatted data, or equivalent Python objects.</p> <pre><code>from jsonpath import pointer\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nsue_score = pointer.resolve(\"/users/0/score\", data)\nprint(sue_score)  # 100\njane_score = pointer.resolve([\"users\", 3, \"score\"], data)\nprint(jane_score)  # 55\n</code></pre> <p>If the pointer can't be resolved against the target JSON document - due to missing keys/properties or out of range indices - a <code>JSONPointerIndexError</code>, <code>JSONPointerKeyError</code> or <code>JSONPointerTypeError</code> will be raised, each of which inherit from <code>JSONPointerResolutionError</code>. A default value can be given, which will be returned in the event of a <code>JSONPointerResolutionError</code>.</p> <pre><code>from jsonpath import pointer\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n]\n}\nsue_score = pointer.resolve(\"/users/99/score\", data, default=0)\nprint(sue_score)  # 0\n</code></pre> <p>See also <code>JSONPathMatch.pointer()</code>, which builds a <code>JSONPointer</code> from a <code>JSONPathMatch</code>.</p>"},{"location":"quickstart/#patchapplypatch-data","title":"<code>patch.apply(patch, data)</code>","text":"<p>New in version 0.8.0</p> <p>Apply a JSON Patch (RFC 6902) to some data. A JSON Patch defines update operation to perform on a JSON document.</p> <p>patch can be a string or file-like object containing a valid JSON Patch document, or an iterable of dictionaries.</p> <p>data is the target JSON document to modify. If data is a string or file-like object, it will be loaded with json.loads. Otherwise data should be a JSON-like data structure and will be modified in place.</p> <pre><code>from jsonpath import patch\npatch_operations = [\n{\"op\": \"add\", \"path\": \"/some/foo\", \"value\": {\"foo\": {}}},\n{\"op\": \"add\", \"path\": \"/some/foo\", \"value\": {\"bar\": []}},\n{\"op\": \"copy\", \"from\": \"/some/other\", \"path\": \"/some/foo/else\"},\n{\"op\": \"add\", \"path\": \"/some/foo/bar/-\", \"value\": 1},\n]\ndata = {\"some\": {\"other\": \"thing\"}}\npatch.apply(patch_operations, data)\nprint(data) # {'some': {'other': 'thing', 'foo': {'bar': [1], 'else': 'thing'}}}\n</code></pre> <p>Use the JSONPatch class to create a patch for repeated application.</p> <pre><code>from jsonpath import JSONPatch\npatch = JSONPatch(\n[\n{\"op\": \"add\", \"path\": \"/some/foo\", \"value\": {\"foo\": {}}},\n{\"op\": \"add\", \"path\": \"/some/foo\", \"value\": {\"bar\": []}},\n{\"op\": \"copy\", \"from\": \"/some/other\", \"path\": \"/some/foo/else\"},\n{\"op\": \"add\", \"path\": \"/some/foo/bar/-\", \"value\": 1},\n]\n)\ndata = {\"some\": {\"other\": \"thing\"}}\npatch.apply(data)\nprint(data)  # {'some': {'other': 'thing', 'foo': {'bar': [1], 'else': 'thing'}}}\n</code></pre> <p>JSONPatch also offers a builder API for constructing JSON patch documents. We use strings as JSON Pointers in this example, but existing JSONPointer instances are OK too.</p> <pre><code>from jsonpath import JSONPatch\npatch = (\nJSONPatch()\n.add(\"/some/foo\", {\"foo\": []})\n.add(\"/some/foo\", {\"bar\": []})\n.copy(\"/some/other\", \"/some/foo/else\")\n.add(\"/some/foo/bar/-\", \"/some/foo/else\")\n)\ndata = {\"some\": {\"other\": \"thing\"}}\npatch.apply(data)\nprint(data)  # {'some': {'other': 'thing', 'foo': {'bar': [1], 'else': 'thing'}}}\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What's Next?","text":"<p>Read about user-defined filter functions at Function Extensions, or see how to make extra data available to filters with Extra Filter Context.</p> <p><code>findall()</code>, <code>finditer()</code> and <code>compile()</code> are shortcuts that use the default<code>JSONPathEnvironment</code>. <code>jsonpath.findall(path, data)</code> is equivalent to:</p> <pre><code>jsonpath.JSONPathEnvironment().compile(path).findall(data)\n</code></pre> <p>If you would like to customize Python JSONPath, see Advanced Usage.</p>"},{"location":"syntax/","title":"JSONPath Syntax","text":"<p>Python JSONPath's default syntax is an opinionated combination of JSONPath features from existing, popular implementations, and much of the IETF JSONPath draft. If you're already familiar with JSONPath syntax, skip to notable differences.</p> <p>Imagine a JSON document as a tree structure, where each object (mapping) and array can contain more objects, arrays and scalar values. Every object, array and scalar value is a node in the tree, and the outermost object or array is the \"root\" node.</p> <p>For our purposes, a JSON \"document\" could be a file containing valid JSON data, a Python string containing valid JSON data, or a Python <code>Object</code> made up of dictionaries (or any Mapping), lists (or any Sequence), strings, etc.</p> <p>We chain selectors together to retrieve nodes from the target document. Each selector operates on the nodes matched by preceding selectors. What follows is a description of those selectors.</p>"},{"location":"syntax/#selectors","title":"Selectors","text":""},{"location":"syntax/#root","title":"Root (<code>$</code>)","text":"<p><code>$</code> refers to the first node in the target document, be it an object or an array. Unless referencing the root node from inside a filter expression, <code>$</code> is optional. The following two examples are equivalent.</p> <pre><code>$.categories.*.name\n</code></pre> <pre><code>categories.*.name\n</code></pre> <p>An empty path or a path containing just the root (<code>$</code>) selector returns the input data in its entirety.</p>"},{"location":"syntax/#properties-thing-thing-or-thing","title":"Properties (<code>.thing</code>, <code>[thing]</code> or <code>['thing']</code>)","text":"<p>Select nodes by property/key name using dot notation (<code>.something</code>) or bracket notation (<code>[something]</code>). If a target property/key contains reserved characters, it must use bracket notation and be enclosed in quotes (<code>['thing']</code>).</p> <p>A dot in front of bracket notation is OK, but unnecessary. The following examples are equivalent.</p> <pre><code>$.categories[0].name\n</code></pre> <pre><code>$.categories[0][name]\n</code></pre> <pre><code>$.categories[0]['name']\n</code></pre>"},{"location":"syntax/#array-indices-0-or-1","title":"Array indices (<code>[0]</code> or <code>[-1]</code>)","text":"<p>Select an item from an array by its index. Indices are zero-based and enclosed in brackets. If the index is negative, items are selected from the end of the array. Considering example data from the top of this page, the following examples are equivalent.</p> <pre><code>$.categories[0]\n</code></pre> <pre><code>$.categories[-1]\n</code></pre>"},{"location":"syntax/#wildcard-or","title":"Wildcard (<code>.*</code> or <code>[*]</code>)","text":"<p>Select all elements from an array or all values from an object using <code>*</code>. These two examples are equivalent.</p> <pre><code>$.categories[0].products.*\n</code></pre> <pre><code>$.categories[0].products[*]\n</code></pre>"},{"location":"syntax/#keys-or","title":"Keys (<code>.~</code> or <code>[~]</code>)","text":"<p>New in version 0.6.0</p> <p>Select keys/properties from an object using <code>~</code>.</p> <pre><code>$.categories.~\n</code></pre> <pre><code>$.categories[~]\n</code></pre>"},{"location":"syntax/#slices-0-1-or-10-1","title":"Slices (<code>[0:-1]</code> or <code>[-1:0:-1]</code>)","text":"<p>Select a range of elements from an array using slice notation. The start index, stop index and step are all optional. These examples are equivalent.</p> <pre><code>$.categories[0:]\n</code></pre> <pre><code>$.categories[0:-1:]\n</code></pre> <pre><code>$.categories[0:-1:1]\n</code></pre> <pre><code>$.categories[::]\n</code></pre>"},{"location":"syntax/#lists-1-2-1020","title":"Lists (<code>[1, 2, 10:20]</code>)","text":"<p>Select multiple indices, slices or properties using list notation (sometimes known as a \"union\" or \"segment\", we use \"union\" to mean something else).</p> <pre><code>$..products.*.[title, price]\n</code></pre>"},{"location":"syntax/#recursive-descent","title":"Recursive descent (<code>..</code>)","text":"<p>The <code>..</code> selector visits every node beneath the current selection. If a property selector, using dot notation, follows <code>..</code>, the dot is optional. These two examples are equivalent.</p> <pre><code>$..title\n</code></pre> <pre><code>$...title\n</code></pre>"},{"location":"syntax/#filters-expression","title":"Filters (<code>[?EXPRESSION]</code>)","text":"<p>Filters allow you to remove nodes from a selection using a Boolean expression. When filtering a mapping-like object, <code>#</code> references the current key/property and <code>@</code> references the current value associated with <code>#</code>. When filtering a sequence-like object, <code>@</code> references the current item and <code>#</code> will hold the item's index in the sequence.</p> <pre><code>$..products[?(@.price &lt; $.price_cap)]\n</code></pre> <pre><code>$..products[?@.price &lt; $.price_cap]\n</code></pre> <p>Comparison operators include <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. Plus <code>&lt;&gt;</code> as an alias for <code>!=</code>.</p> <p><code>in</code> and <code>contains</code> are membership operators. <code>left in right</code> is equivalent to <code>right contains left</code>.</p> <p><code>&amp;&amp;</code> and <code>||</code> are logical operators, <code>and</code> and <code>or</code> work too.</p> <p><code>=~</code> matches the left value with a regular expression literal. Regular expressions use a syntax similar to that found in JavaScript, where the pattern to match is surrounded by slashes, optionally followed by flags.</p> <pre><code>$..products[?(@.description =~ /.*trainers/i)]\n</code></pre> <p>Filter expressions can call predefined function extensions too.</p> <pre><code>$.categories[?count(@.products.*) &gt;= 2]\n</code></pre> <p><code>undefined</code> can be used to filter on the absence of a key/property or an undefined value returned from a filter function. <code>missing</code> is an alias for <code>undefined</code>.</p> <pre><code>$..products[?@.sale_price == undefined]\n</code></pre>"},{"location":"syntax/#union-and-intersection","title":"Union (<code>|</code>) and intersection (<code>&amp;</code>)","text":"<p>Union (<code>|</code>) and intersection (<code>&amp;</code>) are similar to Python's set operations, but we don't dedupe the matches (matches will often contain unhashable objects).</p> <p>The <code>|</code> operator combines matches from two or more paths. This example selects a single list of all prices, plus the price cap as the last element.</p> <pre><code>$..products.*.price | $.price_cap\n</code></pre> <p>The <code>&amp;</code> operator produces matches that are common to both left and right paths. This example would select the list of products that are common to both the \"footwear\" and \"headwear\" categories.</p> <pre><code>$.categories[?(@.name == 'footwear')].products.* &amp; $.categories[?(@.name == 'headwear')].products.*\n</code></pre> <p>Note that <code>|</code> and <code>&amp;</code> are not allowed inside filter expressions.</p>"},{"location":"syntax/#notable-differences","title":"Notable differences","text":"<p>This is a list of things that you might find in other JSONPath implementation that we don't support (yet).</p> <ul> <li>We don't support extension functions of the form <code>selector.func()</code>.</li> <li>We always return a list of matches from <code>jsonpath.findall()</code>, never a scalar value.</li> <li>We do not support arithmetic in filter expression.</li> <li>We don't allow dotted array indices. An array index must be surrounded by square brackets.</li> <li>Python JSONPath is strictly read only. There are no update \"selectors\", but we do provide methods for converting <code>JSONPathMatch</code> instances to <code>JSONPointer</code>s, and a <code>JSONPatch</code> builder API for modifying JSON-like data structures using said pointers.</li> <li>We don't attempt to handle JSON documents without a top-level array or object (or equivalent Python objects).</li> </ul> <p>And this is a list of areas where we deviate from the IETF JSONPath draft.</p> <ul> <li>The root token (default <code>$</code>) is optional and paths starting with a dot (<code>.</code>) are OK. <code>.thing</code> is the same as <code>$.thing</code>, as is <code>thing</code>, <code>$[thing]</code> and <code>$[\"thing\"]</code>.</li> <li>Whitespace is mostly insignificant unless inside quotes.</li> <li>The built-in <code>match()</code> and <code>search()</code> filter functions use Python's standard library <code>re</code> module, which, at least, doesn't support Unicode properties. We might add an implementation of <code>match()</code> and <code>search()</code> using the third party regex package in the future.</li> <li>We don't require property names to be quoted inside a bracketed selection, unless the name contains reserved characters.</li> <li>We don't require the recursive descent segment to have a selector. <code>$..</code> is equivalent to <code>$..*</code>.</li> <li>We support explicit comparisons to <code>undefined</code> as well as implicit existence tests.</li> <li>Float literals without a fractional digit are OK. <code>1.</code> is equivalent to <code>1.0</code>.</li> </ul> <p>And this is a list of features that are uncommon or unique to Python JSONPath.</p> <ul> <li>We support membership operators <code>in</code> and <code>contains</code>, plus list/array literals.</li> <li><code>|</code> is a union operator, where matches from two or more JSONPaths are combined. This is not part of the Python API, but built-in to the JSONPath syntax.</li> <li><code>&amp;</code> is an intersection operator, where we exclude matches that don't exist in both left and right paths. This is not part of the Python API, but built-in to the JSONPath syntax.</li> <li><code>#</code> is the current key/property or index identifier when filtering a mapping or sequence.</li> <li><code>_</code> is a filter context selector. With usage similar to <code>$</code> and <code>@</code>, <code>_</code> exposes arbitrary data from the <code>filter_context</code> argument to <code>findall()</code> and <code>finditer()</code>.</li> <li><code>~</code> is a \"keys\" or \"properties\" selector.</li> </ul>"}]}