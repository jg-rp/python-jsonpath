{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python JSONPath","text":"<p>JSONPath is a mini language for selecting objects from data formatted in JavaScript Object Notation, or equivalent Python objects, like dictionaries and lists.</p>"},{"location":"#install","title":"Install","text":"<p>Install Python JSONPath using pip:</p> <pre><code>pip install python-jsonpath\n</code></pre> <p>Or Pipenv:</p> <pre><code>pipenv install python-jsonpath\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>import jsonpath\nexample_data = {\n\"categories\": [\n{\n\"name\": \"footwear\",\n\"products\": [\n{\n\"title\": \"Trainers\",\n\"description\": \"Fashionable trainers.\",\n\"price\": 89.99,\n},\n{\n\"title\": \"Barefoot Trainers\",\n\"description\": \"Running trainers.\",\n\"price\": 130.00,\n},\n],\n},\n{\n\"name\": \"headwear\",\n\"products\": [\n{\n\"title\": \"Cap\",\n\"description\": \"Baseball cap\",\n\"price\": 15.00,\n},\n{\n\"title\": \"Beanie\",\n\"description\": \"Winter running hat.\",\n\"price\": 9.00,\n},\n],\n},\n],\n\"price_cap\": 10,\n}\nproducts = jsonpath.findall(\"$..products.*\", example_data)\nprint(products)\n</code></pre> <p>Which results in a list of all products from all categories:</p> <pre><code>[\n{\n\"title\": \"Trainers\",\n\"description\": \"Fashionable trainers.\",\n\"price\": 89.99\n},\n{\n\"title\": \"Barefoot Trainers\",\n\"description\": \"Running trainers.\",\n\"price\": 130.0\n},\n{\n\"title\": \"Cap\",\n\"description\": \"Baseball cap\",\n\"price\": 15.0\n},\n{\n\"title\": \"Beanie\",\n\"description\": \"Winter running hat.\",\n\"price\": 9.0\n}\n]\n</code></pre> <p>Or, reading data from a JSON formatted file:</p> <pre><code>import jsonpath\nwith open(\"some.json\") as fd:\nproducts = jsonpath.findall(\"$..products.*\", fd)\nprint(products)\n</code></pre> <p>You could use Python JSONPath on data read from a YAML formatted file too, or any data format that can be loaded into dictionaries and lists. If you have PyYAML installed:</p> <pre><code>import jsonpath\nimport yaml\nwith open(\"some.yaml\") as fd:\ndata = yaml.safe_load(fd)\nproducts = jsonpath.findall(\"$..products.*\", data)\nprint(products)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Have a read through the Quick Start and High Level API Reference, or the default JSONPath Syntax supported by Python JSONPath.</p> <p>If you're interested in customizing JSONPath, take a look at Advanced Usage and the Low Level API Reference.</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#filter-variables","title":"Filter Variables","text":"<p>Arbitrary variables can be made available to filter expressions using the filter_context argument to <code>findall()</code> and <code>finditer()</code>. filter_context should be a mapping of strings to JSON-like objects, like lists, dictionaries, strings and integers.</p> <p>Filter context variables are selected using the filter context selector, which defaults to <code>_</code> and has usage similar to <code>$</code> and <code>@</code>.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nuser_names = jsonpath.findall(\n\"$.users[?@.score &lt; _.limit].name\",\ndata,\nfilter_context={\"limit\": 100},\n)\n</code></pre>"},{"location":"advanced/#function-extensions","title":"Function Extensions","text":"<p>Add, remove or replace filter functions by updating the <code>function_extensions</code> attribute of a <code>JSONPathEnvironment</code>. It is a regular Python dictionary mapping filter function names to any callable, like a function or class with a <code>__call__</code> method.</p>"},{"location":"advanced/#example","title":"Example","text":"<p>As an example, we'll add a <code>min()</code> filter function, which will return the minimum of a sequence of values. If any of the values are not comparable, we'll return the special <code>undefined</code> value instead.</p> <pre><code>from typing import Iterable\nimport jsonpath\ndef min_filter(obj: object) -&gt; object:\nif not isinstance(obj, Iterable):\nreturn jsonpath.UNDEFINED\ntry:\nreturn min(obj)\nexcept TypeError:\nreturn jsonpath.UNDEFINED\nenv = jsonpath.JSONPathEnvironment()\nenv.function_extensions[\"min\"] = min_filter\n</code></pre> <p>Now, when we use <code>env.finall()</code>, <code>env.finditer()</code> or <code>env.compile()</code>, our <code>min</code> function will be available for use in filter expressions.</p> <pre><code>$..products[?@.price == min($..products.price)]\n</code></pre>"},{"location":"advanced/#built-in-functions","title":"Built-in Functions","text":"<p>The built-in functions can be removed from a <code>JSONPathEnvironment</code> by deleting the entry from <code>function_extensions</code>.</p> <pre><code>import jsonpath\nenv = jsonpath.JSONPathEnvironment()\ndel env.function_extensions[\"keys\"]\n</code></pre> <p>Or aliased with an additional entry.</p> <pre><code>import jsonpath\nenv = jsonpath.JSONPathEnvironment()\nenv.function_extensions[\"properties\"] = env.function_extensions[\"keys\"]\n</code></pre> <p>Alternatively, you could subclass <code>JSONPathEnvironment</code> and override the <code>setup_function_extensions</code> method.</p> <pre><code>from typing import Iterable\nimport jsonpath\nclass MyEnv(jsonpath.JSONPathEnvironment):\ndef setup_function_extensions(self) -&gt; None:\nsuper().setup_function_extensions()\nself.function_extensions[\"properties\"] = self.function_extensions[\"keys\"]\nself.function_extensions[\"min\"] = min_filter\ndef min_filter(obj: object) -&gt; object:\nif not isinstance(obj, Iterable):\nreturn jsonpath.UNDEFINED\ntry:\nreturn min(obj)\nexcept TypeError:\nreturn jsonpath.UNDEFINED\nenv = MyEnv()\n</code></pre>"},{"location":"advanced/#compile-time-validation","title":"Compile Time Validation","text":"<p>A function extension's arguments can be validated at compile time by implementing the function as a class with a <code>__call__</code> method, and a <code>validate</code> method. <code>validate</code> will be called after parsing the function, giving you the opportunity to inspect its arguments and raise a <code>JSONPathTypeError</code> should any arguments be unacceptable. If defined, <code>validate</code> must take a reference to the current environment, an argument list and the token pointing to the start of the function call.</p> <pre><code>def validate(\nself,\nenv: JSONPathEnvironment,\nargs: List[FilterExpression],\ntoken: Token,\n) -&gt; List[FilterExpression]:\n</code></pre> <p>It should return an argument list, either the same as the input argument list, or a modified version of it. See the implementation of the built-in <code>match</code> function for an example.</p>"},{"location":"advanced/#custom-environments","title":"Custom Environments","text":"<p>Python JSONPath can be customized by subclassing <code>JSONPathEnvironment</code> and overriding class attributes and/or methods. Then using <code>findall()</code>, <code>finditer()</code> and <code>compile()</code> methods of that subclass.</p>"},{"location":"advanced/#identifier-tokens","title":"Identifier Tokens","text":"<p>The default identifier tokens, like <code>$</code> and <code>@</code>, can be changed by setting attributes a on <code>JSONPathEnvironment</code>. This example sets the root token (default <code>$</code>) to be <code>^</code>.</p> <pre><code>import jsonpath\nclass MyJSONPathEnvironment(jsonpath.JSONPathEnvironment):\nroot_token = \"^\"\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n],\n\"limit\": 100,\n}\nenv = MyJSONPathEnvironment()\nuser_names = env.findall(\n\"^.users[?@.score &lt; ^.limit].name\",\ndata,\n)\n</code></pre> <p>This table shows all available identifier token attributes.</p> attribute default filter_context_token <code>_</code> keys_token <code>#</code> root_token <code>$</code> self_token <code>@</code>"},{"location":"advanced/#operator-tokens","title":"Operator Tokens","text":"<p>TODO:</p>"},{"location":"advanced/#keys-selector","title":"Keys Selector","text":"<p>TODO:</p>"},{"location":"advanced/#array-index-limits","title":"Array Index Limits","text":"<p>TODO:</p>"},{"location":"advanced/#subclassing-lexer","title":"Subclassing Lexer","text":"<p>TODO:</p>"},{"location":"advanced/#subclassing-parser","title":"Subclassing Parser","text":"<p>TODO:</p>"},{"location":"advanced/#get-item","title":"Get Item","text":"<p>TODO:</p>"},{"location":"advanced/#truthiness-and-existence","title":"Truthiness and Existence","text":"<p>TODO:</p>"},{"location":"advanced/#filter-infix-expressions","title":"Filter Infix Expressions","text":"<p>TODO:</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#jsonpath.JSONPathEnvironment","title":"jsonpath.JSONPathEnvironment","text":"<p>JSONPath configuration.</p> <p>This class contains settings for path tokenization, parsing and resolution behavior, plus convenience methods for matching an unparsed path to some data.</p> <p>Most applications will want to create a single <code>JSONPathEnvironment</code>, or use <code>jsonpath.compile()</code>, <code>jsonpath.findall()</code>, etc. from the package-level default environment.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment--environment-customization","title":"Environment customization","text":"<p>Environment customization is achieved by subclassing <code>JSONPathEnvironment</code> and overriding class attributes and/or methods. Some of these customizations include:</p> <ul> <li>Changing the root (<code>$</code>), self (<code>@</code>) or filter context (<code>_</code>) token with   class attributes <code>root_token</code>, <code>self_token</code> and <code>filter_context_token</code>.</li> <li>Registering a custom lexer or parser with the class attributes   <code>lexer_class</code> or <code>parser_class</code>. <code>lexer_class</code> must be a subclass of   <code>Lexer</code> and <code>parser_class</code> must be a subclass of <code>Parser</code>.</li> <li>Setup built-in function extensions by overriding   <code>setup_function_extensions()</code></li> <li>Hook in to mapping and sequence item getting by overriding <code>getitem()</code>.</li> <li>Change filter comparison operator behavior by overriding <code>compare()</code>.</li> </ul>"},{"location":"api/#jsonpath.JSONPathEnvironment--class-attributes","title":"Class attributes","text":"ATTRIBUTE DESCRIPTION <code>filter_context_token</code> <p>The pattern used to select extra filter context data. Defaults to <code>\"_\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>intersection_token</code> <p>The pattern used as the intersection operator. Defaults to <code>\"&amp;\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>key_token</code> <p>The pattern used to identify the current key or index when filtering a, mapping or sequence. Defaults to <code>\"#\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>keys_selector_token</code> <p>The pattern used as the \"keys\" selector. Defaults to <code>\"~\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>lexer_class</code> <p>The lexer to use when tokenizing path strings.</p> <p> TYPE: <code>Type[Lexer]</code> </p> <code>max_int_index</code> <p>The maximum integer allowed when selecting array items by index. Defaults to <code>(2**53) - 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>min_int_index</code> <p>The minimum integer allowed when selecting array items by index. Defaults to <code>-(2**53) + 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>parser_class</code> <p>The parser to use when parsing tokens from the lexer.</p> <p> TYPE: <code>Type[Parser]</code> </p> <code>root_token</code> <p>The pattern used to select the root node in a JSON document. Defaults to <code>\"$\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>self_token</code> <p>The pattern used to select the current node in a JSON document. Defaults to <code>\"@\"</code></p> <p> TYPE: <code>str</code> </p> <code>union_token</code> <p>The pattern used as the union operator. Defaults to <code>\"|\"</code>.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.function_extensions","title":"function_extensions  <code>instance-attribute</code>","text":"<pre><code>function_extensions: Dict[str, Callable[..., Any]] = {}\n</code></pre> <p>A list of function extensions available to filters.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.lexer","title":"lexer  <code>instance-attribute</code>","text":"<pre><code>lexer: Lexer = self.lexer_class(env=self)\n</code></pre> <p>The lexer bound to this environment.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.parser","title":"parser  <code>instance-attribute</code>","text":"<pre><code>parser: Parser = self.parser_class(env=self)\n</code></pre> <p>The parser bound to this environment.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.compare","title":"compare","text":"<pre><code>compare(left: object, operator: str, right: object) -&gt; bool\n</code></pre> <p>Object comparison within JSONPath filters.</p> <p>Override this to customize filter expression comparison operator behavior.</p> PARAMETER DESCRIPTION <code>left</code> <p>The left hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> <code>operator</code> <p>The comparison expression's operator.</p> <p> TYPE: <code>str</code> </p> <code>right</code> <p>The right hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the comparison between left and right, with the</p> <code>bool</code> <p>given operator, is truthy. <code>False</code> otherwise.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.compile","title":"compile","text":"<pre><code>compile(path: str) -&gt; Union[JSONPath, CompoundJSONPath]\n</code></pre> <p>Prepare a path string ready for repeated matching against different data.</p> PARAMETER DESCRIPTION <code>path</code> <p>A JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Union[JSONPath, CompoundJSONPath]</code> <p>A <code>JSONPath</code> or <code>CompoundJSONPath</code>, ready to match against some data. Expect a <code>CompoundJSONPath</code> if the path string uses the union or intersection operators.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.findall","title":"findall","text":"<pre><code>findall(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.finditer","title":"finditer","text":"<pre><code>finditer(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> <p>Raises a <code>JSONPathSyntaxError</code> if the path is invalid.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.getitem","title":"getitem","text":"<pre><code>getitem(obj: Any, key: Any) -&gt; Any\n</code></pre> <p>Sequence and mapping item getter used throughout JSONPath resolution.</p> <p>The default implementation of <code>getitem</code> simply calls <code>operators.getitem()</code> from Python's standard library. Same as <code>obj[key]</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>A mapping or sequence that might contain key.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>A mapping key, sequence index or sequence slice.</p> <p> TYPE: <code>Any</code> </p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.getitem_async","title":"getitem_async  <code>async</code>","text":"<pre><code>getitem_async(obj: Any, key: object) -&gt; Any\n</code></pre> <p>An async sequence and mapping item getter.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.is_truthy","title":"is_truthy","text":"<pre><code>is_truthy(obj: object) -&gt; bool\n</code></pre> <p>Test for truthiness when evaluating JSONPath filter expressions.</p> <p>In some cases, the IETF JSONPath draft requires us to test for existence rather than truthiness. So the default implementation returns <code>True</code> for empty collections and <code>None</code>. The special <code>UNDEFINED</code> object means that obj was missing, as opposed to an explicit <code>None</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>Any object.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the object exists and is not <code>False</code> or <code>0</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.setup_function_extensions","title":"setup_function_extensions","text":"<pre><code>setup_function_extensions() -&gt; None\n</code></pre> <p>Initialize function extensions.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.validate_function_extension_signature","title":"validate_function_extension_signature","text":"<pre><code>validate_function_extension_signature(\ntoken: Token, args: List[Any]\n) -&gt; List[Any]\n</code></pre> <p>Compile-time validation of function extension arguments.</p> <p>The IETF JSONPath draft requires us to reject paths that use filter functions with too many or too few arguments.</p>"},{"location":"api/#jsonpath.JSONPathMatch","title":"jsonpath.JSONPathMatch","text":"<p>A matched object with a concrete path.</p> ATTRIBUTE DESCRIPTION <code>children</code> <p>Matched child nodes. This will only be populated after all children have been visited, usually by using <code>findall()</code> or <code>list(finditer())</code>.</p> <p> TYPE: <code>List[JSONPathMatch]</code> </p> <code>obj</code> <p>The matched object.</p> <p> TYPE: <code>object</code> </p> <code>parent</code> <p>The immediate parent to this match in the JSON document. If this is the root node, parent will be <code>None</code>.</p> <p> TYPE: <code>Optional[JSONPathMatch]</code> </p> <code>path</code> <p>The canonical string representation of the path to this match.</p> <p> TYPE: <code>str</code> </p> <code>parts</code> <p>The keys, indices and/or slices that make up the path to this match.</p> <p> TYPE: <code>Tuple[PathPart, ...]</code> </p> <code>root</code> <p>A reference to the root node in the JSON document.</p> <p> TYPE: <code>Union[Sequence[Any], Mapping[str, Any]]</code> </p>"},{"location":"api/#jsonpath.match.JSONPathMatch.add_child","title":"add_child","text":"<pre><code>add_child(*children: JSONPathMatch) -&gt; None\n</code></pre> <p>Append one or more children to this match.</p>"},{"location":"api/#jsonpath.match.JSONPathMatch.filter_context","title":"filter_context","text":"<pre><code>filter_context() -&gt; FilterContextVars\n</code></pre> <p>Return filter context data for this match.</p>"},{"location":"api/#jsonpath.JSONPath","title":"jsonpath.JSONPath","text":"<p>A compiled JSONPath ready to be applied to a JSON string or Python object.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>JSONPathEnvironment</code> this path is bound to.</p> <p> TYPE: <code>JSONPathEnvironment</code> </p> <code>selectors</code> <p>An iterable of <code>JSONPathSelector</code> objects, as generated by a <code>Parser</code>.</p> <p> TYPE: <code>Iterable[JSONPathSelector]</code> </p>"},{"location":"api/#jsonpath.path.JSONPath.empty","title":"empty","text":"<pre><code>empty() -&gt; bool\n</code></pre> <p>Return <code>True</code> if this path has no selectors.</p>"},{"location":"api/#jsonpath.path.JSONPath.findall","title":"findall","text":"<pre><code>findall(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will</p> <code>List[object]</code> <p>be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.path.JSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> If the path is invalid. <p>JSONPathTypeError: If a filter expression attempts to use types in     an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.CompoundJSONPath","title":"jsonpath.CompoundJSONPath","text":"<p>Multiple <code>JSONPath</code>s combined.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.findall","title":"findall","text":"<pre><code>findall(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.intersection","title":"intersection","text":"<pre><code>intersection(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>In-place intersection of this path and another path.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.union","title":"union","text":"<pre><code>union(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>In-place union of this path and another path.</p>"},{"location":"async/","title":"Async","text":"<p>TODO</p> <p>Coming soon.</p>"},{"location":"custom_api/","title":"Low Level API Reference","text":""},{"location":"custom_api/#jsonpath.token.Token","title":"jsonpath.token.Token","text":"<p>A token, as returned from <code>lex.Lexer.tokenize()</code>.</p> ATTRIBUTE DESCRIPTION <code>kind</code> <p>The token's type. It is always one of the constants defined in jsonpath.token.py.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The path substring containing text for the token.</p> <p> TYPE: <code>str</code> </p> <code>index</code> <p>The index at which value starts in path.</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>A reference to the complete JSONPath string from which this token derives.</p> <p> TYPE: <code>str</code> </p>"},{"location":"custom_api/#jsonpath.token.Token.position","title":"position","text":"<pre><code>position() -&gt; Tuple[int, int]\n</code></pre> <p>Return the line and column number for the start of this token.</p>"},{"location":"custom_api/#jsonpathfilterfilterexpression","title":"jsonpath.filter.FilterExpression","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathlexlexer","title":"jsonpath.lex.Lexer","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathparseparser","title":"jsonpath.parse.Parser","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathselectorsjsonpathselector","title":"jsonpath.selectors.JSONPathSelector","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathstreamtokenstream","title":"jsonpath.stream.TokenStream","text":"<p>TODO:</p>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Each of the following exceptions has a <code>token</code> property, referencing the <code>Token</code> that caused the error. You can use <code>Token.position()</code> to get the token's line and column number.</p>"},{"location":"exceptions/#jsonpath.JSONPathError","title":"jsonpath.JSONPathError","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for all errors.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Optional[Token]</code> DEFAULT: <code>None</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathSyntaxError","title":"jsonpath.JSONPathSyntaxError","text":"<p>         Bases: <code>JSONPathError</code></p> <p>An exception raised when parsing a JSONPath string.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathTypeError","title":"jsonpath.JSONPathTypeError","text":"<p>         Bases: <code>JSONPathError</code></p> <p>An exception raised due to a type error.</p> <p>This should only occur at when evaluating filter expressions.</p>"},{"location":"exceptions/#jsonpath.JSONPathIndexError","title":"jsonpath.JSONPathIndexError","text":"<p>         Bases: <code>JSONPathError</code></p> <p>An exception raised when an array index is out of range.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathNameError","title":"jsonpath.JSONPathNameError","text":"<p>         Bases: <code>JSONPathError</code></p> <p>An exception raised when an unknown function extension is called.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"functions/","title":"Filter Functions","text":"<p>A filter function is a named function that can be called as part of a filter selector expression. Here we describe built-in filters. You can define your own function extensions too.</p>"},{"location":"functions/#count","title":"<code>count()</code>","text":"<pre><code>count(obj: object) -&gt; Optional[int]\n</code></pre> <p>Return the number of items in obj. If the object does not respond to Python's <code>len()</code> function, <code>None</code> is returned.</p> <pre><code>$.categories[?count(@.products.*) &gt;= 2]\n</code></pre>"},{"location":"functions/#isinstance","title":"<code>isinstance()</code>","text":"<p>New in version 0.6.0</p> <pre><code>isinstance(obj: object, t: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the type of obj matches t. This function allows t to be one of several aliases for the real Python \"type\". Some of these aliases follow JavaScript/JSON semantics.</p> type aliases UNDEFINED \"undefined\", \"missing\" None \"null\", \"nil\", \"None\", \"none\" str \"str\", \"string\" Sequence (array-like) \"array\", \"list\", \"sequence\", \"tuple\" Mapping (dict-like) \"object\", \"dict\", \"mapping\" bool \"bool\", \"boolean\" int \"number\", \"int\" float \"number\", \"float\" <p>For example :</p> <pre><code>$.categories[?isinstance(@.length, 'number')]\n</code></pre> <p>And <code>is()</code> is an alias for <code>isinstance()</code>:</p> <pre><code>$.categories[?is(@.length, 'number')]\n</code></pre>"},{"location":"functions/#length","title":"<code>length()</code>","text":"<pre><code>length(obj: object) -&gt; Optional[int]\n</code></pre> <p>Return the number of items in the input object. If the object does not respond to Python's <code>len()</code> function, <code>None</code> is returned.</p> <pre><code>$.categories[?length(@) &gt; 1]\n</code></pre>"},{"location":"functions/#match","title":"<code>match()</code>","text":"<pre><code>match(obj: object, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if obj is a string and is a full match to the regex pattern.</p> <pre><code>$..products[?match(@.title, \".+ainers.+\")]\n</code></pre> <p>If pattern is a string literal, it will be compiled at compile time, and raise a <code>JSONPathTypeError</code> at compile time if it's invalid.</p> <p>If pattern is a query and the result is not a valid regex, <code>False</code> is returned.</p>"},{"location":"functions/#search","title":"<code>search()</code>","text":"<pre><code>search(obj: object, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if obj is a string and it contains the regexp pattern.</p> <pre><code>$..products[?search(@.title, \"ainers\")]\n</code></pre> <p>If pattern is a string literal, it will be compiled at compile time, and raise a <code>JSONPathTypeError</code> at compile time if it's invalid.</p> <p>If pattern is a query and the result is not a valid regex, <code>False</code> is returned.</p>"},{"location":"functions/#typeof","title":"<code>typeof()</code>","text":"<p>New in version 0.6.0</p> <pre><code>typeof(obj: object) -&gt; str\n</code></pre> <p>Return the type of obj as a string. The strings returned from this function use JavaScript/JSON terminology like \"string\", \"array\" and \"object\", much like the result of JavaScript's <code>typeof</code> operator.</p> <pre><code>$.categories[?typeof(@.length) == 'number']\n</code></pre> <p><code>type()</code> is and alias for <code>typeof()</code>.</p>"},{"location":"functions/#value","title":"<code>value()</code>","text":"<pre><code>value(nodes: object) -&gt; object | undefined\n</code></pre> <p>Return the first value from nodes resulting from a JSONPath query, if there is only one node, or <code>undefined</code> otherwise.</p> <pre><code>$..products[?value(@.price) == 9]\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This page gets you started using JSONPath wih Python, see JSONPath Syntax for information on JSONPath selector syntax.</p>"},{"location":"quickstart/#findallpath-data","title":"<code>findall(path, data)</code>","text":"<p>Find all objects matching a JSONPath with <code>jsonpath.findall()</code>. It takes, as arguments, a JSONPath string and some data object. It always returns a list of objects selected from the given data.</p> <p>data can be a file-like object or string containing JSON formatted data, or a Python <code>Mapping</code> or <code>Sequence</code>, like a dictionary or list. In this example we select user names from a dictionary containing a list of user dictionaries.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nuser_names = jsonpath.findall(\"$.users.*.name\", data)\n</code></pre> <p>Where <code>user_names</code> is now equal to:</p> <pre><code>[\"Sue\", \"John\", \"Sally\", \"Jane\"]\n</code></pre> <p>If the same data were in a file called <code>users.json</code>, we might use <code>findall()</code> like this:</p> <pre><code>import jsonpath\nwith open(\"users.json\") as fd:\nuser_names = jsonpath.findall(\"$.users.*.name\", fd)\n</code></pre>"},{"location":"quickstart/#finditerpath-data","title":"<code>finditer(path, data)</code>","text":"<p>Use <code>jsonpath.finditer()</code> to create an iterator which yields instances of <code>jsonpath.JSONPathMatch</code> for every object in some data that matches a JSONPath. It accepts the same arguments as <code>findall()</code>, a path string and data from which to select matches.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nmatches = jsonpath.finditer(\"$.users.*.name\", data)\nfor match in matches:\nprint(matches)\n</code></pre> <p>The string representation of a <code>JSONPathMatch</code> shows the matched object and the canonical path to that object.</p> <pre><code>'Sue' @ $['users'][0]['name']\n'John' @ $['users'][1]['name']\n'Sally' @ $['users'][2]['name']\n'Jane' @ $['users'][3]['name']\n</code></pre> <p>The selected object is available from a <code>JSONPathMatch</code> as <code>obj</code> and its path, as a string, as <code>path</code>. Other useful properties of <code>JSONPathMatch</code> include a reference to the parent match, a list of child matches, and a <code>parts</code> tuple of keys and indices that make up the path.</p>"},{"location":"quickstart/#compilepath","title":"<code>compile(path)</code>","text":"<p>When you have a JSONPath that needs to be matched against different data repeatedly, you can compile the path ahead of time using <code>jsonpath.compile()</code>. It takes a path as a string and returns a <code>JSONPath</code> instance. <code>JSONPath</code> has <code>findall()</code> and <code>finditer()</code> methods that behave similarly to package-level <code>findall()</code> and <code>finditer()</code>, just without the <code>path</code> argument.</p> <pre><code>import jsonpath\nsome_data = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n]\n}\nother_data = {\n\"users\": [\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\npath = jsonpath.compile(\"$.users.*.name\")\nsome_users = path.findall(some_data)\nother_users = path.findall(other_data)\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What's Next?","text":"<p>Read about user-defined filter functions at Function Extensions, or see how to make extra data available to filters with Extra Filter Context.</p> <p><code>findall()</code>, <code>finditer()</code> and <code>compile()</code> are shortcuts that use the default<code>JSONPathEnvironment</code>. <code>jsonpath.findall(path, data)</code> is equivalent to:</p> <pre><code>jsonpath.JSONPathEnvironment().compile(path).findall(data)\n</code></pre> <p>If you would like to use a customize Python JSONPath, see Advanced Usage.</p>"},{"location":"syntax/","title":"JSONPath Syntax","text":"<p>Python JSONPath's default syntax is an opinionated combination of JSONPath features from existing, popular implementations, and much of the IETF JSONPath draft. If you're already familiar with JSONPath syntax, skip to notable differences.</p> <p>Imagine a JSON document as a tree structure, where each object (mapping) and array can contain more objects, arrays and scalar values. Every object, array and scalar value is a node in the tree, and the outermost object or array is the \"root\" node.</p> <p>For our purposes, a JSON \"document\" could be a file containing valid JSON data, a Python string containing valid JSON data, or a Python <code>Object</code> made up of dictionaries (or any Mapping), lists (or any Sequence), strings, etc.</p> <p>We chain selectors together to retrieve nodes from the target document. Each selector operates on the nodes matched by preceding selectors. What follows is a description of those selectors.</p>"},{"location":"syntax/#selectors","title":"Selectors","text":""},{"location":"syntax/#root","title":"Root (<code>$</code>)","text":"<p><code>$</code> refers to the first node in the target document, be it an object or an array. Unless referencing the root node from inside a filter expression, <code>$</code> is optional. The following two examples are equivalent.</p> <pre><code>$.categories.*.name\n</code></pre> <pre><code>categories.*.name\n</code></pre> <p>An empty path or a path containing just the root (<code>$</code>) selector returns the input data in its entirety.</p>"},{"location":"syntax/#properties-thing-thing-or-thing","title":"Properties (<code>.thing</code>, <code>[thing]</code> or <code>['thing']</code>)","text":"<p>Select nodes by property/key name using dot notation (<code>.something</code>) or bracket notation (<code>[something]</code>). If a target property/key contains reserved characters, it must use bracket notation and be enclosed in quotes (<code>['thing']</code>).</p> <p>A dot in front of bracket notation is OK, but unnecessary. The following examples are equivalent.</p> <pre><code>$.categories[0].name\n</code></pre> <pre><code>$.categories[0][name]\n</code></pre> <pre><code>$.categories[0]['name']\n</code></pre>"},{"location":"syntax/#array-indices-0-or-1","title":"Array indices (<code>[0]</code> or <code>[-1]</code>)","text":"<p>Select an item from an array by its index. Indices are zero-based and enclosed in brackets. If the index is negative, items are selected from the end of the array. Considering example data from the top of this page, the following examples are equivalent.</p> <pre><code>$.categories[0]\n</code></pre> <pre><code>$.categories[-1]\n</code></pre>"},{"location":"syntax/#wildcard-or","title":"Wildcard (<code>.*</code> or <code>[*]</code>)","text":"<p>Select all elements from an array or all values from an object using <code>*</code>. These two examples are equivalent.</p> <pre><code>$.categories[0].products.*\n</code></pre> <pre><code>$.categories[0].products[*]\n</code></pre>"},{"location":"syntax/#keys-or","title":"Keys (<code>.~</code> or <code>[~]</code>)","text":"<p>New in version 0.6.0</p> <p>Select keys/properties from an object using <code>~</code>.</p> <pre><code>$.categories.~\n</code></pre> <pre><code>$.categories[~]\n</code></pre>"},{"location":"syntax/#slices-0-1-or-10-1","title":"Slices (<code>[0:-1]</code> or <code>[-1:0:-1]</code>)","text":"<p>Select a range of elements from an array using slice notation. The start index, stop index and step are all optional. These examples are equivalent.</p> <pre><code>$.categories[0:]\n</code></pre> <pre><code>$.categories[0:-1:]\n</code></pre> <pre><code>$.categories[0:-1:1]\n</code></pre> <pre><code>$.categories[::]\n</code></pre>"},{"location":"syntax/#lists-1-2-1020","title":"Lists (<code>[1, 2, 10:20]</code>)","text":"<p>Select multiple indices, slices or properties using list notation (sometimes known as a \"union\" or \"segment\", we use \"union\" to mean something else).</p> <pre><code>$..products.*.[title, price]\n</code></pre>"},{"location":"syntax/#recursive-descent","title":"Recursive descent (<code>..</code>)","text":"<p>The <code>..</code> selector visits every node beneath the current selection. If a property selector, using dot notation, follows <code>..</code>, the dot is optional. These two examples are equivalent.</p> <pre><code>$..title\n</code></pre> <pre><code>$...title\n</code></pre>"},{"location":"syntax/#filters-expression","title":"Filters (<code>[?EXPRESSION]</code>)","text":"<p>Filters allow you to remove nodes from a selection using a Boolean expression. When filtering a mapping-like object, <code>#</code> references the current key/property and <code>@</code> references the current value associated with <code>#</code>. When filtering a sequence-like object, <code>@</code> references the current item and <code>#</code> will hold the item's index in the sequence.</p> <pre><code>$..products[?(@.price &lt; $.price_cap)]\n</code></pre> <pre><code>$..products[?@.price &lt; $.price_cap]\n</code></pre> <p>Comparison operators include <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. Plus <code>&lt;&gt;</code> as an alias for <code>!=</code>.</p> <p><code>in</code> and <code>contains</code> are membership operators. <code>left in right</code> is equivalent to <code>right contains left</code>.</p> <p><code>&amp;&amp;</code> and <code>||</code> are logical operators, <code>and</code> and <code>or</code> work too.</p> <p><code>=~</code> matches the left value with a regular expression literal. Regular expressions use a syntax similar to that found in JavaScript, where the pattern to match is surrounded by slashes, optionally followed by flags.</p> <pre><code>$..products[?(@.description =~ /.*trainers/i)]\n</code></pre> <p>Filter expressions can call predefined function extensions too.</p> <pre><code>$.categories[?count(@.products.*) &gt;= 2]\n</code></pre> <p><code>undefined</code> can be used to filter on the absence of a key/property or an undefined value returned from a filter function. <code>missing</code> is an alias for <code>undefined</code>.</p> <pre><code>$..products[?@.sale_price == undefined]\n</code></pre>"},{"location":"syntax/#union-and-intersection","title":"Union (<code>|</code>) and intersection (<code>&amp;</code>)","text":"<p>Union (<code>|</code>) and intersection (<code>&amp;</code>) are similar to Python's set operations, but we don't dedupe the matches (matches will often contain unhashable objects).</p> <p>The <code>|</code> operator combines matches from two or more paths. This example selects a single list of all prices, plus the price cap as the last element.</p> <pre><code>$..products.*.price | $.price_cap\n</code></pre> <p>The <code>&amp;</code> operator produces matches that are common to both left and right paths. This example would select the list of products that are common to both the \"footwear\" and \"headwear\" categories.</p> <pre><code>$.categories[?(@.name == 'footwear')].products.* &amp; $.categories[?(@.name == 'headwear')].products.*\n</code></pre> <p>Note that <code>|</code> and <code>&amp;</code> are not allowed inside filter expressions.</p>"},{"location":"syntax/#notable-differences","title":"Notable differences","text":"<p>This is a list of things that you might find in other JSONPath implementation that we don't support (yet).</p> <ul> <li>We don't support extension functions of the form <code>selector.func()</code>.</li> <li>We always return a list of matches from <code>jsonpath.findall()</code>, never a scalar value.</li> <li>We do not support arithmetic in filter expression.</li> <li>Python JSONPath is strictly read only. There are no update \"selectors\", although a Python API for working with <code>JSONPathMatch</code>s may well be added in the future.</li> </ul> <p>And this is a list of areas where we deviate from the IETF JSONPath draft.</p> <ul> <li>We don't yet follow all \"non-singular query\" rules when evaluating a filter comparison.</li> <li>We don't yet force the result of some filter functions to be compared.</li> <li>Whitespace is mostly insignificant unless inside quotes.</li> <li>The root token (default <code>$</code>) is optional.</li> <li>Paths starting with a dot (<code>.</code>) are OK. <code>.thing</code> is the same as <code>$.thing</code>, as is <code>thing</code>, <code>$[thing]</code> and <code>$[\"thing\"]</code>.</li> <li>The built-in <code>match()</code> and <code>search()</code> filter functions use Python's standard library <code>re</code> module, which, at least, doesn't support Unicode properties. We might add an implementation of <code>match()</code> and <code>search()</code> using the third party regex package in the future.</li> <li>We silently ignore unnecessary escaping when parsing some quoted selectors. The standard treats this as an \"invalid selector\".</li> </ul> <p>And this is a list of features that are uncommon or unique to Python JSONPath.</p> <ul> <li><code>|</code> is a union operator, where matches from two or more JSONPaths are combined. This is not part of the Python API, but built-in to the JSONPath syntax.</li> <li><code>&amp;</code> is an intersection operator, where we exclude matches that don't exist in both left and right paths. This is not part of the Python API, but built-in to the JSONPath syntax.</li> <li><code>#</code> is the current key/property or index identifier when filtering a mapping or sequence.</li> <li><code>_</code> is a filter context selector. With usage similar to <code>$</code> and <code>@</code>, <code>_</code> exposes arbitrary data from the <code>filter_context</code> argument to <code>findall()</code> and <code>finditer()</code>.</li> <li><code>~</code> is a \"keys\" or \"properties\" selector.</li> </ul>"}]}