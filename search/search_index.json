{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python JSONPath","text":"<p>JSONPath is a mini language for selecting objects from data formatted in JavaScript Object Notation, or equivalent Python objects, like dictionaries and lists.</p>"},{"location":"#install","title":"Install","text":"<p>Install Python JSONPath using pip:</p> <pre><code>pip install python-jsonpath\n</code></pre> <p>Or Pipenv:</p> <pre><code>pipenv install python-jsonpath\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>import jsonpath\nexample_data = {\n\"categories\": [\n{\n\"name\": \"footwear\",\n\"products\": [\n{\n\"title\": \"Trainers\",\n\"description\": \"Fashionable trainers.\",\n\"price\": 89.99,\n},\n{\n\"title\": \"Barefoot Trainers\",\n\"description\": \"Running trainers.\",\n\"price\": 130.00,\n},\n],\n},\n{\n\"name\": \"headwear\",\n\"products\": [\n{\n\"title\": \"Cap\",\n\"description\": \"Baseball cap\",\n\"price\": 15.00,\n},\n{\n\"title\": \"Beanie\",\n\"description\": \"Winter running hat.\",\n\"price\": 9.00,\n},\n],\n},\n],\n\"price_cap\": 10,\n}\nproducts = jsonpath.findall(\"$..products.*\", example_data)\nprint(products)\n</code></pre> <p>Which results in a list of all products from all categories:</p> <pre><code>[\n{\n\"title\": \"Trainers\",\n\"description\": \"Fashionable trainers.\",\n\"price\": 89.99\n},\n{\n\"title\": \"Barefoot Trainers\",\n\"description\": \"Running trainers.\",\n\"price\": 130.0\n},\n{\n\"title\": \"Cap\",\n\"description\": \"Baseball cap\",\n\"price\": 15.0\n},\n{\n\"title\": \"Beanie\",\n\"description\": \"Winter running hat.\",\n\"price\": 9.0\n}\n]\n</code></pre> <p>Or, reading data from a JSON formatted file:</p> <pre><code>import jsonpath\nwith open(\"some.json\") as fd:\nproducts = jsonpath.findall(\"$..products.*\", fd)\nprint(products)\n</code></pre> <p>You could use Python JSONPath on data read from a YAML formatted file too, or any data format that can be loaded into dictionaries and lists. If you have PyYAML installed:</p> <pre><code>import jsonpath\nimport yaml\nwith open(\"some.yaml\") as fd:\ndata = yaml.safe_load(fd)\nproducts = jsonpath.findall(\"$..products.*\", data)\nprint(products)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Have a read through the Quick Start and High Level API Reference, or the default JSONPath Syntax supported by Python JSONPath.</p> <p>If you're interested in customizing JSONPath, take a look at Advanced Usage and the Low Level API Reference.</p>"},{"location":"advanced/","title":"Advanced","text":"<p>TODO</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#jsonpath.JSONPathEnvironment","title":"jsonpath.JSONPathEnvironment","text":"<p>JSONPath configuration.</p> <p>This class contains settings for path tokenization, parsing and resolution behavior, plus convenience methods for matching an unparsed path to some data.</p> <p>Most applications will want to create a single <code>JSONPathEnvironment</code>, or use <code>jsonpath.compile()</code>, <code>jsonpath.findall()</code>, etc. from the package-level default environment.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment--environment-customization","title":"Environment customization","text":"<p>Environment customization is achieved by subclassing <code>JSONPathEnvironment</code> and overriding class attributes and/or methods. Some of these customizations include:</p> <ul> <li>Changing the root (<code>$</code>), self (<code>@</code>) or filter context (<code>#</code>) token with   class attributes <code>root_token</code>, <code>self_token</code> and <code>filter_context_token</code>.</li> <li>Registering a custom lexer or parser with the class attributes   <code>lexer_class</code> or <code>parser_class</code>. <code>lexer_class</code> must be a subclass of   <code>Lexer</code> and <code>parser_class</code> must be a subclass of <code>Parser</code>.</li> <li>Setup built-in function extensions by overriding   <code>setup_function_extensions()</code></li> <li>Hook in to mapping and sequence item getting by overriding <code>getitem()</code>.</li> <li>Change filter comparison operator behavior by overriding <code>compare()</code>.</li> </ul>"},{"location":"api/#jsonpath.JSONPathEnvironment--class-attributes","title":"Class attributes","text":"ATTRIBUTE DESCRIPTION <code>filter_context_token</code> <p>The pattern used to select extra filter context data. Defaults to <code>\"#\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>intersection_token</code> <p>The pattern used as the intersection operator. Defaults to <code>\"$\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>lexer_class</code> <p>The lexer to use when tokenizing path strings.</p> <p> TYPE: <code>Type[Lexer]</code> </p> <code>max_int_index</code> <p>The maximum integer allowed when selecting array items by index. Defaults to <code>(2**53) - 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>min_int_index</code> <p>The minimum integer allowed when selecting array items by index. Defaults to <code>-(2**53) + 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>parser_class</code> <p>The parser to use when parsing tokens from the lexer.</p> <p> TYPE: <code>Type[Parser]</code> </p> <code>root_token</code> <p>The pattern used to select the root node in a JSON document. Defaults to <code>\"$\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>self_token</code> <p>The pattern used to select the current node in a JSON document. Defaults to <code>\"@\"</code></p> <p> TYPE: <code>str</code> </p> <code>union_token</code> <p>The pattern used as the union operator. Defaults to <code>\"|\"</code>.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.function_extensions","title":"function_extensions  <code>instance-attribute</code>","text":"<pre><code>function_extensions: Dict[str, Callable[..., Any]] = {}\n</code></pre> <p>A list of function extensions available to filters.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.lexer","title":"lexer  <code>instance-attribute</code>","text":"<pre><code>lexer: Lexer = self.lexer_class(env=self)\n</code></pre> <p>The lexer bound to this environment.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.parser","title":"parser  <code>instance-attribute</code>","text":"<pre><code>parser: Parser = self.parser_class(env=self)\n</code></pre> <p>The parser bound to this environment.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.compare","title":"compare","text":"<pre><code>compare(left: object, operator: str, right: object) -&gt; bool\n</code></pre> <p>Object comparison within JSONPath filters.</p> <p>Override this to customize filter expression comparison operator behavior.</p> PARAMETER DESCRIPTION <code>left</code> <p>The left hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> <code>operator</code> <p>The comparison expression's operator.</p> <p> TYPE: <code>str</code> </p> <code>right</code> <p>The right hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the comparison between left and right, with the</p> <code>bool</code> <p>given operator, is truthy. <code>False</code> otherwise.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.compile","title":"compile","text":"<pre><code>compile(path: str) -&gt; Union[JSONPath, CompoundJSONPath]\n</code></pre> <p>Prepare a path string ready for repeated matching against different data.</p> PARAMETER DESCRIPTION <code>path</code> <p>A JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Union[JSONPath, CompoundJSONPath]</code> <p>A <code>JSONPath</code> or <code>CompoundJSONPath</code>, ready to match against some data. Expect a <code>CompoundJSONPath</code> if the path string uses the union or intersection operators.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.findall","title":"findall","text":"<pre><code>findall(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.finditer","title":"finditer","text":"<pre><code>finditer(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> <p>Raises a <code>JSONPathSyntaxError</code> if the path is invalid.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\npath: str,\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.getitem","title":"getitem","text":"<pre><code>getitem(obj: Any, key: Any) -&gt; Any\n</code></pre> <p>Sequence and mapping item getter used throughout JSONPath resolution.</p> <p>The default implementation of <code>getitem</code> simply calls <code>operators.getitem()</code> from Python's standard library. Same as <code>obj[key]</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>A mapping or sequence that might contain key.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>A mapping key, sequence index or sequence slice.</p> <p> TYPE: <code>Any</code> </p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.getitem_async","title":"getitem_async  <code>async</code>","text":"<pre><code>getitem_async(obj: Any, key: object) -&gt; Any\n</code></pre> <p>An async sequence and mapping item getter.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.is_truthy","title":"is_truthy","text":"<pre><code>is_truthy(obj: object) -&gt; bool\n</code></pre> <p>Test for truthiness when evaluating JSONPath filter expressions.</p> <p>In some cases, the IETF JSONPath draft requires us to test for existence rather than truthiness. So the default implementation returns <code>True</code> for empty collections and <code>None</code>. The special <code>UNDEFINED</code> object means that obj was missing, as opposed to an explicit <code>None</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>Any object.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the object exists and is not <code>False</code> or <code>0</code>.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.setup_function_extensions","title":"setup_function_extensions","text":"<pre><code>setup_function_extensions() -&gt; None\n</code></pre> <p>Initialize function extensions.</p>"},{"location":"api/#jsonpath.env.JSONPathEnvironment.validate_function_extension_signature","title":"validate_function_extension_signature","text":"<pre><code>validate_function_extension_signature(\ntoken: Token, args: List[Any]\n) -&gt; List[Any]\n</code></pre> <p>Compile-time validation of function extension arguments.</p> <p>The IETF JSONPath draft requires us to reject paths that use filter functions with too many or too few arguments.</p>"},{"location":"api/#jsonpath.JSONPathMatch","title":"jsonpath.JSONPathMatch","text":"<p>A matched object with a concrete path.</p> ATTRIBUTE DESCRIPTION <code>children</code> <p>Matched child nodes. This will only be populated after all children have been visited, usually by using <code>findall()</code> or <code>list(finditer())</code>.</p> <p> TYPE: <code>List[JSONPathMatch]</code> </p> <code>obj</code> <p>The matched object.</p> <p> TYPE: <code>object</code> </p> <code>parent</code> <p>The immediate parent to this match in the JSON document. If this is the root node, parent will be <code>None</code>.</p> <p> TYPE: <code>Optional[JSONPathMatch]</code> </p> <code>path</code> <p>The canonical string representation of the path to this match.</p> <p> TYPE: <code>str</code> </p> <code>parts</code> <p>The keys, indices and/or slices that make up the path to this match.</p> <p> TYPE: <code>Tuple[PathPart, ...]</code> </p> <code>root</code> <p>A reference to the root node in the JSON document.</p> <p> TYPE: <code>Union[Sequence[Any], Mapping[str, Any]]</code> </p>"},{"location":"api/#jsonpath.match.JSONPathMatch.add_child","title":"add_child","text":"<pre><code>add_child(*children: JSONPathMatch) -&gt; None\n</code></pre> <p>Append one or more children to this match.</p>"},{"location":"api/#jsonpath.match.JSONPathMatch.filter_context","title":"filter_context","text":"<pre><code>filter_context() -&gt; FilterContextVars\n</code></pre> <p>Return filter context data for this match.</p>"},{"location":"api/#jsonpath.JSONPath","title":"jsonpath.JSONPath","text":"<p>A compiled JSONPath ready to be applied to a JSON string or Python object.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>JSONPathEnvironment</code> this path is bound to.</p> <p> TYPE: <code>JSONPathEnvironment</code> </p> <code>selectors</code> <p>An iterable of <code>JSONPathSelector</code> objects, as generated by a <code>Parser</code>.</p> <p> TYPE: <code>Iterable[JSONPathSelector]</code> </p>"},{"location":"api/#jsonpath.path.JSONPath.empty","title":"empty","text":"<pre><code>empty() -&gt; bool\n</code></pre> <p>Return <code>True</code> if this path has no selectors.</p>"},{"location":"api/#jsonpath.path.JSONPath.findall","title":"findall","text":"<pre><code>findall(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will</p> <code>List[object]</code> <p>be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.path.JSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> If the path is invalid. <p>JSONPathTypeError: If a filter expression attempts to use types in     an incompatible way.</p>"},{"location":"api/#jsonpath.path.JSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\n*,\nfilter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.CompoundJSONPath","title":"jsonpath.CompoundJSONPath","text":"<p>Multiple <code>JSONPath</code>s combined.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.findall","title":"findall","text":"<pre><code>findall(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>Union[str, TextIO, Sequence[Any], Mapping[str, Any]]</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\ndata: Union[\nstr, TextIO, Sequence[Any], Mapping[str, Any]\n],\nfilter_context: Optional[FilterContextVars] = None,\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.intersection","title":"intersection","text":"<pre><code>intersection(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>In-place intersection of this path and another path.</p>"},{"location":"api/#jsonpath.path.CompoundJSONPath.union","title":"union","text":"<pre><code>union(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>In-place union of this path and another path.</p>"},{"location":"async/","title":"Async","text":"<p>TODO</p> <p>Coming soon.</p>"},{"location":"custom_api/","title":"Low Level API Reference","text":"<p>TODO</p>"},{"location":"exceptions/","title":"Exceptions","text":"<p>TODO: mention accessing the token and position</p>"},{"location":"exceptions/#jsonpath.JSONPathError","title":"jsonpath.JSONPathError","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for all JSONPath syntax and type errors.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Optional[Token]</code> DEFAULT: <code>None</code> </p>"},{"location":"functions/","title":"Filter Functions","text":"<p>A filter function is a named function that can be called as part of a filter selector expression. Here we describe the standard, built-in filters. You can define your own function extensions too.</p>"},{"location":"functions/#count","title":"<code>count()</code>","text":"<pre><code>count(obj: object) -&gt; Optional[int]\n</code></pre> <p>Return the number of items in obj. If the object does not respond to Python's <code>len()</code> function, <code>None</code> is returned.</p> <pre><code>$.categories[?count(@.products.*) &gt;= 2]\n</code></pre> <p>Warning</p> <p>As of Python JSONPath version 0.5.0, <code>count</code> is an alias for <code>length</code>. This might change in the future.</p>"},{"location":"functions/#length","title":"<code>length()</code>","text":"<pre><code>length(obj: object) -&gt; Optional[int]\n</code></pre> <p>Return the number of items in the input object. If the object does not respond to Python's <code>len()</code> function, <code>None</code> is returned.</p> <pre><code>$.categories[?length(@) &gt; 1]\n</code></pre>"},{"location":"functions/#match","title":"<code>match()</code>","text":"<pre><code>match(obj: object, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if obj is a string and is a full match to the regex pattern.</p> <pre><code>$..products[?match(@.title, \".+ainers.+\")]\n</code></pre> <p>If pattern is a string literal, it will be compiled at compile time, and raise a <code>JSONPathTypeError</code> at compile time if it's invalid.</p> <p>If pattern is a query and the result is not a valid regex, <code>False</code> is returned.</p>"},{"location":"functions/#search","title":"<code>search()</code>","text":"<pre><code>search(obj: object, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if obj is a string and it contains the regexp pattern.</p> <pre><code>$..products[?search(@.title, \"ainers\")]\n</code></pre> <p>If pattern is a string literal, it will be compiled at compile time, and raise a <code>JSONPathTypeError</code> at compile time if it's invalid.</p> <p>If pattern is a query and the result is not a valid regex, <code>False</code> is returned.</p>"},{"location":"functions/#value","title":"<code>value()</code>","text":"<pre><code>value(nodes: object) -&gt; object | undefined\n</code></pre> <p>Return the first value from nodes resulting from a JSONPath query, if there is only one node, or <code>undefined</code> otherwise.</p> <pre><code>$..products[?value(@.price) == 9]\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This page gets you starting with Python JSONPath, see JSONPath Syntax for information on JSONPath selector syntax.</p>"},{"location":"quickstart/#findall","title":"<code>findall</code>","text":"<p>Find all objects matching a JSONPath with <code>jsonpath.findall()</code>. It takes, as arguments, a JSONPath string and some data object. It always returns a list of objects selected from the given data.</p> <p>data can be a file-like object or string containing JSON formatted data, or a Python <code>Mapping</code> or <code>Sequence</code>, like a dictionary or list. In this example we select user names from a dictionary containing a list of user dictionaries.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nuser_names = jsonpath.findall(\"$.users.*.name\", data)\n</code></pre> <p>Where <code>user_names</code> is now equal to:</p> <pre><code>[\"Sue\", \"John\", \"Sally\", \"Jane\"]\n</code></pre> <p>If the same data were in a file called <code>users.json</code>, we might use <code>findall()</code> like this:</p> <pre><code>import jsonpath\nwith open(\"users.json\") as fd:\nuser_names = jsonpath.findall(\"$.users.*.name\", fd)\n</code></pre>"},{"location":"quickstart/#finditer","title":"<code>finditer</code>","text":"<p>Use <code>jsonpath.finditer()</code> to create an iterator which yields instances of <code>jsonpath.JSONPathMatch</code> for every object in some data that matches a JSONPath. It accepts the same arguments as <code>findall()</code>, a path string and data from which to select matches.</p> <pre><code>import jsonpath\ndata = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\nmatches = jsonpath.finditer(\"$.users.*.name\", data)\nfor match in matches:\nprint(matches)\n</code></pre> <p>The string representation of a <code>JSONPathMatch</code> shows the matched object and the canonical path to that object.</p> <pre><code>'Sue' @ $['users'][0]['name']\n'John' @ $['users'][1]['name']\n'Sally' @ $['users'][2]['name']\n'Jane' @ $['users'][3]['name']\n</code></pre> <p>The selected object is available from a <code>JSONPathMatch</code> as <code>obj</code> and its path, as a string, as <code>path</code>. Other useful properties of <code>JSONPathMatch</code> include a reference to the parent match, a list of child matches, and a <code>parts</code> tuple of keys and indices that make up the path.</p>"},{"location":"quickstart/#compile","title":"<code>compile</code>","text":"<p>When you have a JSONPath that needs to be matched against different data repeatedly, you can compile the path ahead of time using <code>jsonpath.compile()</code>. It takes a path as a string and returns a <code>JSONPath</code> instance. <code>JSONPath</code> has <code>findall()</code> and <code>finditer()</code> methods that behave similarly to package-level <code>findall()</code> and <code>finditer()</code>, just without the <code>path</code> argument.</p> <pre><code>import jsonpath\nsome_data = {\n\"users\": [\n{\n\"name\": \"Sue\",\n\"score\": 100,\n},\n{\n\"name\": \"John\",\n\"score\": 86,\n},\n]\n}\nother_data = {\n\"users\": [\n{\n\"name\": \"Sally\",\n\"score\": 84,\n},\n{\n\"name\": \"Jane\",\n\"score\": 55,\n},\n]\n}\npath = jsonpath.compile(\"$.users.*.name\")\nsome_users = path.findall(some_data)\nother_users = path.findall(other_data)\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What's Next","text":"<p>Read about user-defined filter functions at Function Extensions, or see how to make extra data available to filters with Extra Filter Context.</p> <p><code>findall</code>, <code>finditer</code> and <code>compile</code> are shortcuts that use the default<code>JSONPathEnvironment</code>. <code>jsonpath.findall(path, data)</code> is equivalent to <code>jsonpath.JSONPathEnvironment().compile(path).findall(data)</code>. If you would like to use a custom environment, see Advanced Usage.</p>"},{"location":"syntax/","title":"JSONPath Syntax","text":"<p>Python JSONPath's default syntax is an opinionated combination of JSONPath features from existing, popular implementations, and much of the IETF JSONPath draft. If you're already familiar with JSONPath syntax, skip to notable differences.</p> <p>Imagine a JSON document as a tree structure, where each object (mapping) and array can contain more objects, arrays and scalar values. Every object, array and scalar value is a node in the tree, and the outermost object or array is the \"root\" node.</p> <p>For our purposes, a JSON \"document\" could be a file containing valid JSON data, a Python string containing valid JSON data, or a Python <code>Object</code> made up of dictionaries (or any Mapping), lists (or any Sequence), strings, etc.</p> <p>We chain selectors together to retrieve nodes from the target document. Each selector operates on the nodes matched by preceding selectors. What follows is a description of those selectors.</p>"},{"location":"syntax/#selectors","title":"Selectors","text":""},{"location":"syntax/#root","title":"Root (<code>$</code>)","text":"<p><code>$</code> refers to the first node in the target document, be it an object or an array. Unless referencing the root node from inside a filter expression, <code>$</code> is optional. The following two examples are equivalent.</p> <pre><code>$.categories.*.name\n</code></pre> <pre><code>categories.*.name\n</code></pre> <p>An empty path or a path containing just the root (<code>$</code>) selector returns the input data in its entirety.</p>"},{"location":"syntax/#properties-thing-thing-or-thing","title":"Properties (<code>.thing</code>, <code>[thing]</code> or <code>['thing']</code>)","text":"<p>Select nodes by property/key name using dot notation (<code>.something</code>) or bracket notation (<code>[something]</code>). If a target property/key contains reserved characters, it must use bracket notation and be enclosed in quotes (<code>['thing']</code>).</p> <p>A dot in front of bracket notation is OK, but unnecessary. The following examples are equivalent.</p> <pre><code>$.categories[0].name\n</code></pre> <pre><code>$.categories[0][name]\n</code></pre> <pre><code>$.categories[0]['name']\n</code></pre>"},{"location":"syntax/#array-indices-0-or-1","title":"Array indices (<code>[0]</code> or <code>[-1]</code>)","text":"<p>Select an item from an array by its index. Indices are zero-based and enclosed in brackets. If the index is negative, items are selected from the end of the array. Considering example data from the top of this page, the following examples are equivalent.</p> <pre><code>$.categories[0]\n</code></pre> <pre><code>$.categories[-1]\n</code></pre>"},{"location":"syntax/#wildcard-or","title":"Wildcard (<code>.*</code> or <code>[*]</code>)","text":"<p>Select all elements from an array or all values from an object using <code>*</code>. These two examples are equivalent.</p> <pre><code>$.categories[0].products.*\n</code></pre> <pre><code>$.categories[0].products[*]\n</code></pre>"},{"location":"syntax/#slices-0-1-or-10-1","title":"Slices (<code>[0:-1]</code> or <code>[-1:0:-1]</code>)","text":"<p>Select a range of elements from an array using slice notation. The start index, stop index and step are all optional. These examples are equivalent.</p> <pre><code>$.categories[0:]\n</code></pre> <pre><code>$.categories[0:-1:]\n</code></pre> <pre><code>$.categories[0:-1:1]\n</code></pre> <pre><code>$.categories[::]\n</code></pre>"},{"location":"syntax/#lists-1-2-1020","title":"Lists (<code>[1, 2, 10:20]</code>)","text":"<p>Select multiple indices, slices or properties using list notation (sometimes known as a \"union\" or \"segment\", we use \"union\" to mean something else).</p> <pre><code>$..products.*.[title, price]\n</code></pre>"},{"location":"syntax/#recursive-descent","title":"Recursive descent (<code>..</code>)","text":"<p>The <code>..</code> selector visits every node beneath the current selection. If a property selector, using dot notation, follows <code>..</code>, the dot is optional. These two examples are equivalent.</p> <pre><code>$..title\n</code></pre> <pre><code>$...title\n</code></pre>"},{"location":"syntax/#filters-expression","title":"Filters (<code>[?(EXPRESSION)]</code>)","text":"<p>Filters allow you to remove nodes from a selection using a Boolean expression. Within a filter, <code>@</code> refers to the current node and <code>$</code> refers to the root node in the target document. <code>@</code> and <code>$</code> can be used to select nodes as part of the expression. Since version 0.3.0, the parentheses are optional, as per the IETF JSONPath draft. These two examples are equivalent.</p> <pre><code>$..products[?(@.price &lt; $.price_cap)]\n</code></pre> <pre><code>$..products[?@.price &lt; $.price_cap]\n</code></pre> <p>Comparison operators include <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. Plus <code>&lt;&gt;</code> as an alias for <code>!=</code>.</p> <p><code>in</code> and <code>contains</code> are membership operators. <code>left in right</code> is equivalent to <code>right contains left</code>.</p> <p><code>&amp;&amp;</code> and <code>||</code> are logical operators, <code>and</code> and <code>or</code> work too.</p> <p><code>=~</code> matches the left value with a regular expression literal. Regular expressions use a syntax similar to that found in JavaScript, where the pattern to match is surrounded by slashes, optionally followed by flags.</p> <pre><code>$..products[?(@.description =~ /.*trainers/i)]\n</code></pre> <p>Filters can use function extensions too.</p>"},{"location":"syntax/#union-and-intersection","title":"Union (<code>|</code>) and intersection (<code>&amp;</code>)","text":"<p>Union (<code>|</code>) and intersection (<code>&amp;</code>) are similar to Python's set operations, but we don't dedupe the matches (matches will often contain unhashable objects).</p> <p>The <code>|</code> operator combines matches from two or more paths. This example selects a single list of all prices, plus the price cap as the last element.</p> <pre><code>$..products.*.price | $.price_cap\n</code></pre> <p>The <code>&amp;</code> operator produces matches that are common to both left and right paths. This example would select the list of products that are common to both the \"footwear\" and \"headwear\" categories.</p> <pre><code>$.categories[?(@.name == 'footwear')].products.* &amp; $.categories[?(@.name == 'headwear')].products.*\n</code></pre> <p>Note that <code>|</code> and <code>&amp;</code> are not allowed inside filter expressions.</p>"},{"location":"syntax/#notable-differences","title":"Notable differences","text":"<p>This is a list of things that you might find in other JSONPath implementation that we don't support (yet).</p> <ul> <li>We don't support extension functions of the form <code>selector.func()</code>.</li> <li>We always return a list of matches from <code>jsonpath.findall()</code>, never a scalar value.</li> <li>We do not support arithmetic in filter expression.</li> <li>Python JSONPath is strictly read only. There are no update \"selectors\", although a Python API for working with <code>JSONPathMatch</code>s may well be added in the future.</li> </ul> <p>And this is a list of areas where we deviate from the IETF JSONPath draft.</p> <ul> <li>We don't require filters that use a function extension to include a comparison operator.</li> <li>Whitespace is mostly insignificant unless inside quotes.</li> <li>The root token (default <code>$</code>) is optional.</li> <li>Paths starting with a dot (<code>.</code>) are OK. <code>.thing</code> is the same as <code>$.thing</code>, as is <code>thing</code>, <code>$[thing]</code> and <code>$[\"thing\"]</code>.</li> </ul> <p>And this is a list of features that are uncommon or unique to Python JSONPath.</p> <ul> <li><code>|</code> is a union operator, where matches from two or more JSONPaths are combined. This is not part of the Python API, but built-in to the JSONPath syntax.</li> <li><code>&amp;</code> is an intersection operator, where we exclude matches that don't exist in both left and right paths. This is not part of the Python API, but built-in to the JSONPath syntax.</li> <li><code>#</code> is a filter context selector. With usage similar to <code>$</code> and <code>@</code>, <code>#</code> exposes arbitrary data from the <code>filter_context</code> argument to <code>findall()</code> and <code>finditer()</code>.</li> </ul>"}]}