{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python JSONPath","text":"<p>JSONPath is a mini language for selecting values from data formatted in JavaScript Object Notation, or equivalent Python objects, like dictionaries and lists.</p> <p>Python JSONPath is a non-evaluating, read-only implementation of JSONPath, suitable for situations where JSONPath query authors are untrusted. We follow RFC 9535 and test against the JSONPath Compliance Test Suite.</p> <p>We also include implementations of JSON Pointer (RFC 6901) and JSON Patch (RFC 6902), plus methods for converting a JSONPathMatch to a <code>JSONPointer</code>.</p>"},{"location":"#install","title":"Install","text":"<p>Install Python JSONPath using pip:</p> <pre><code>pip install python-jsonpath\n</code></pre> <p>Or Pipenv:</p> <pre><code>pipenv install python-jsonpath\n</code></pre> <p>Or pipx</p> <pre><code>pipx install python-jsonpath\n</code></pre> <p>Or from conda-forge:</p> <pre><code>conda install -c conda-forge python-jsonpath\n</code></pre>"},{"location":"#optional-dependencies","title":"Optional dependencies","text":"<p>Python JSONPath works out of the box with no extra dependencies, and its syntax is already very close to RFC 9535.</p> <p>For strict compliance with the specification, strict mode and the <code>strict</code> extra were added in version 2.0.0.</p> <pre><code>pip install python-jsonpath[strict]\n</code></pre> <p>This installs <code>regex</code> and <code>iregexp-check</code>, enabling:</p> <ul> <li><code>match()</code> and <code>search()</code> to use <code>regex</code> instead of Python's built-in <code>re</code> module.</li> <li>Validation of regular expressions against RFC 9485.</li> </ul> <p>See the syntax guide for strict mode details and specification extensions.</p>"},{"location":"#example","title":"Example","text":"<pre><code>import jsonpath\n\nexample_data = {\n    \"categories\": [\n        {\n            \"name\": \"footwear\",\n            \"products\": [\n                {\n                    \"title\": \"Trainers\",\n                    \"description\": \"Fashionable trainers.\",\n                    \"price\": 89.99,\n                },\n                {\n                    \"title\": \"Barefoot Trainers\",\n                    \"description\": \"Running trainers.\",\n                    \"price\": 130.00,\n                },\n            ],\n        },\n        {\n            \"name\": \"headwear\",\n            \"products\": [\n                {\n                    \"title\": \"Cap\",\n                    \"description\": \"Baseball cap\",\n                    \"price\": 15.00,\n                },\n                {\n                    \"title\": \"Beanie\",\n                    \"description\": \"Winter running hat.\",\n                    \"price\": 9.00,\n                },\n            ],\n        },\n    ],\n    \"price_cap\": 10,\n}\n\nproducts = jsonpath.findall(\"$..products.*\", example_data)\nprint(products)\n</code></pre> <p>Which results in a list of all products from all categories:</p> <pre><code>[\n  {\n    \"title\": \"Trainers\",\n    \"description\": \"Fashionable trainers.\",\n    \"price\": 89.99\n  },\n  {\n    \"title\": \"Barefoot Trainers\",\n    \"description\": \"Running trainers.\",\n    \"price\": 130.0\n  },\n  {\n    \"title\": \"Cap\",\n    \"description\": \"Baseball cap\",\n    \"price\": 15.0\n  },\n  {\n    \"title\": \"Beanie\",\n    \"description\": \"Winter running hat.\",\n    \"price\": 9.0\n  }\n]\n</code></pre> <p>Or, reading data from a JSON formatted file:</p> <pre><code>import jsonpath\n\nwith open(\"some.json\") as fd:\n    products = jsonpath.findall(\"$..products.*\", fd)\n\nprint(products)\n</code></pre> <p>You could use Python JSONPath on data read from a YAML formatted file too, or any data format that can be loaded into dictionaries and lists. If you have PyYAML installed:</p> <pre><code>import jsonpath\nimport yaml\n\nwith open(\"some.yaml\") as fd:\n    data = yaml.safe_load(fd)\n\nproducts = jsonpath.findall(\"$..products.*\", data)\nprint(products)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Have a read through the Quick Start and High Level API Reference, or the default JSONPath Syntax supported by Python JSONPath.</p> <p>If you're interested in customizing JSONPath, take a look at Advanced Usage and the Low Level API Reference.</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#filter-variables","title":"Filter Variables","text":"<p>Arbitrary variables can be made available to filter selectors using the <code>filter_context</code> argument to <code>findall()</code> and <code>finditer()</code>. <code>filter_context</code> should be a mapping of strings to JSON-like objects, like lists, dictionaries, strings and integers.</p> <p>Filter context variables are selected using a filter query starting with the filter context identifier, which defaults to <code>_</code> and has usage similar to <code>$</code> and <code>@</code>.</p> <pre><code>import jsonpath\n\ndata = {\n    \"users\": [\n        {\n            \"name\": \"Sue\",\n            \"score\": 100,\n        },\n        {\n            \"name\": \"John\",\n            \"score\": 86,\n        },\n        {\n            \"name\": \"Sally\",\n            \"score\": 84,\n        },\n        {\n            \"name\": \"Jane\",\n            \"score\": 55,\n        },\n    ]\n}\n\nuser_names = jsonpath.findall(\n    \"$.users[?@.score &lt; _.limit].name\",\n    data,\n    filter_context={\"limit\": 100},\n)\n</code></pre>"},{"location":"advanced/#function-extensions","title":"Function Extensions","text":"<p>Add, remove or replace filter functions by updating the <code>function_extensions</code> attribute of a <code>JSONPathEnvironment</code>. It is a regular Python dictionary mapping filter function names to any callable, like a function or class with a <code>__call__</code> method.</p>"},{"location":"advanced/#type-system-for-function-expressions","title":"Type System for Function Expressions","text":"<p>Section 2.4.1 of RFC 9535 defines a type system for function expressions and requires that we check that filter expressions are well-typed. With that in mind, you are encouraged to implement custom filter functions by extending <code>jsonpath.function_extensions.FilterFunction</code>, which forces you to be explicit about the types of arguments the function extension accepts and the type of its return value.</p> <p>Info</p> <p><code>FilterFunction</code> was new in Python JSONPath version 0.10.0. Prior to that we did not enforce function expression well-typedness. To use any arbitrary callable as a function extension - or if you don't want built-in filter functions to raise a <code>JSONPathTypeError</code> for function expressions that are not well-typed - set <code>well_typed</code> to <code>False</code> when constructing a <code>JSONPathEnvironment</code>.</p>"},{"location":"advanced/#example","title":"Example","text":"<p>As an example, we'll add a <code>min()</code> filter function, which will return the minimum of a sequence of values. If any of the values are not comparable, we'll return the special <code>undefined</code> value instead.</p> <pre><code>from typing import Iterable\n\nimport jsonpath\nfrom jsonpath.function_extensions import ExpressionType\nfrom jsonpath.function_extensions import FilterFunction\n\n\nclass MinFilterFunction(FilterFunction):\n    \"\"\"A JSONPath function extension returning the minimum of a sequence.\"\"\"\n\n    arg_types = [ExpressionType.VALUE]\n    return_type = ExpressionType.VALUE\n\n    def __call__(self, value: object) -&gt; object:\n        if not isinstance(value, Iterable):\n            return jsonpath.UNDEFINED\n\n        try:\n            return min(value)\n        except TypeError:\n            return jsonpath.UNDEFINED\n\n\nenv = jsonpath.JSONPathEnvironment()\nenv.function_extensions[\"min\"] = MinFilterFunction()\n\nexample_data = {\"foo\": [{\"bar\": [4, 5]}, {\"bar\": [1, 5]}]}\nprint(env.findall(\"$.foo[?min(@.bar) &gt; 1]\", example_data))\n</code></pre> <p>Now, when we use <code>env.finall()</code>, <code>env.finditer()</code> or <code>env.compile()</code>, our <code>min</code> function will be available for use in filter expressions.</p> <pre><code>$..products[?@.price == min($..products.price)]\n</code></pre>"},{"location":"advanced/#built-in-functions","title":"Built-in Functions","text":"<p>The built-in functions can be removed from a <code>JSONPathEnvironment</code> by deleting the entry from <code>function_extensions</code>.</p> <pre><code>import jsonpath\n\nenv = jsonpath.JSONPathEnvironment()\ndel env.function_extensions[\"keys\"]\n</code></pre> <p>Or aliased with an additional entry.</p> <pre><code>import jsonpath\n\nenv = jsonpath.JSONPathEnvironment()\nenv.function_extensions[\"properties\"] = env.function_extensions[\"keys\"]\n</code></pre> <p>Alternatively, you could subclass <code>JSONPathEnvironment</code> and override the <code>setup_function_extensions</code> method.</p> <pre><code>from typing import Iterable\nimport jsonpath\n\nclass MyEnv(jsonpath.JSONPathEnvironment):\n    def setup_function_extensions(self) -&gt; None:\n        super().setup_function_extensions()\n        self.function_extensions[\"properties\"] = self.function_extensions[\"keys\"]\n        self.function_extensions[\"min\"] = min_filter\n\n\ndef min_filter(obj: object) -&gt; object:\n    if not isinstance(obj, Iterable):\n        return jsonpath.UNDEFINED\n\n    try:\n        return min(obj)\n    except TypeError:\n        return jsonpath.UNDEFINED\n\nenv = MyEnv()\n</code></pre>"},{"location":"advanced/#compile-time-validation","title":"Compile Time Validation","text":"<p>Calls to type-aware function extension are validated at JSONPath compile-time automatically. If <code>well_typed</code> is set to <code>False</code> or a custom function extension does not inherit from <code>FilterFunction</code>, its arguments can be validated by implementing the function as a class with a <code>__call__</code> method, and a <code>validate</code> method. <code>validate</code> will be called after parsing the function, giving you the opportunity to inspect its arguments and raise a <code>JSONPathTypeError</code> should any arguments be unacceptable. If defined, <code>validate</code> must take a reference to the current environment, an argument list and the token pointing to the start of the function call.</p> <pre><code>def validate(\n        self,\n        env: JSONPathEnvironment,\n        args: List[FilterExpression],\n        token: Token,\n) -&gt; List[FilterExpression]:\n</code></pre> <p>It should return an argument list, either the same as the input argument list, or a modified version of it. See the implementation of the built-in <code>match</code> function for an example.</p>"},{"location":"advanced/#custom-environments","title":"Custom Environments","text":"<p>Python JSONPath can be customized by subclassing <code>JSONPathEnvironment</code> and overriding class attributes and/or methods. Then using <code>findall()</code>, <code>finditer()</code> and <code>compile()</code> methods of that subclass.</p>"},{"location":"advanced/#identifier-tokens","title":"Identifier Tokens","text":"<p>The default identifier tokens, like <code>$</code> and <code>@</code>, can be changed by setting attributes a on <code>JSONPathEnvironment</code>. This example sets the root token (default <code>$</code>) to be <code>^</code>.</p> <pre><code>import JSONPathEnvironment\n\nclass MyJSONPathEnvironment(JSONPathEnvironment):\n    root_token = \"^\"\n\n\ndata = {\n    \"users\": [\n        {\"name\": \"Sue\", \"score\": 100},\n        {\"name\": \"John\", \"score\": 86},\n        {\"name\": \"Sally\", \"score\": 84},\n        {\"name\": \"Jane\", \"score\": 55},\n    ],\n    \"limit\": 100,\n}\n\nenv = MyJSONPathEnvironment()\nuser_names = env.findall(\n    \"^.users[?@.score &lt; ^.limit].name\",\n    data,\n)\n</code></pre> <p>This table shows all available identifier token attributes.</p> attribute default filter_context_token <code>_</code> keys_token <code>#</code> root_token <code>$</code> self_token <code>@</code>"},{"location":"advanced/#logical-operator-tokens","title":"Logical Operator Tokens","text":"<p>By default, we accept both Python and C-style logical operators in filter expressions. That is, <code>not</code> and <code>!</code> are equivalent, <code>and</code> and <code>&amp;&amp;</code> are equivalent and <code>or</code> and <code>||</code> are equivalent. You can change this using class attributes on a <code>Lexer</code> subclass and setting the <code>lexer_class</code> attribute on a <code>JSONPathEnvironment</code>.</p> <p>This example changes all three logical operators to strictly match the JSONPath spec.</p> <pre><code>from jsonpath import JSONPathEnvironment\nfrom jsonpath import Lexer\n\nclass MyLexer(Lexer):\n    logical_not_pattern = r\"!\"\n    logical_and_pattern = r\"&amp;&amp;\"\n    logical_or_pattern = r\"\\|\\|\"\n\nclass MyJSONPathEnvironment(JSONPathEnvironment):\n    lexer_class = MyLexer\n\nenv = MyJSONPathEnvironment()\nenv.compile(\"$.foo[?@.a &gt; 0 &amp;&amp; @.b &lt; 100]\")  # OK\nenv.compile(\"$.foo[?@.a &gt; 0 and @.b &lt; 100]\")  # JSONPathSyntaxError\n</code></pre>"},{"location":"advanced/#keys-selector","title":"Keys Selector","text":"<p>The non-standard keys selector is used to retrieve the keys/properties from a JSON Object or Python mapping. It defaults to <code>~</code> and can be changed using the <code>keys_selector_token</code> attribute on a <code>JSONPathEnvironment</code> subclass.</p> <p>This example changes the keys selector to <code>*~</code>.</p> <pre><code>from jsonpath import JSONPathEnvironment\n\nclass MyJSONPathEnvironment(JSONPathEnvironment):\n    keys_selector_token = \"*~\"\n\ndata = {\n    \"users\": [\n        {\"name\": \"Sue\", \"score\": 100},\n        {\"name\": \"John\", \"score\": 86},\n        {\"name\": \"Sally\", \"score\": 84},\n        {\"name\": \"Jane\", \"score\": 55},\n    ],\n    \"limit\": 100,\n}\n\nenv = MyJSONPathEnvironment()\nprint(env.findall(\"$.users[0].*~\", data))  # ['name', 'score']\n</code></pre>"},{"location":"advanced/#array-index-limits","title":"Array Index Limits","text":"<p>Python JSONPath limits the minimum and maximum JSON array or Python sequence indices (including slice steps) allowed in a JSONPath query. The default minimum allowed index is set to <code>-(2**53) + 1</code>, and the maximum to <code>(2**53) - 1</code>. When a limit is reached, a <code>JSONPathIndexError</code> is raised.</p> <p>You can change the minimum and maximum allowed indices using the <code>min_int_index</code> and <code>max_int_index</code> attributes on a <code>JSONPathEnvironment</code> subclass.</p> <pre><code>from jsonpath import JSONPathEnvironment\n\nclass MyJSONPathEnvironment(JSONPathEnvironment):\n    min_int_index = -100\n    max_int_index = 100\n\nenv = MyJSONPathEnvironment()\nquery = env.compile(\"$.users[999]\")\n# jsonpath.exceptions.JSONPathIndexError: index out of range, line 1, column 8\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#jsonpath.JSONPathEnvironment","title":"jsonpath.JSONPathEnvironment","text":"<p>JSONPath configuration.</p> <p>This class contains settings for path tokenization, parsing and resolution behavior, plus convenience methods for matching an unparsed path to some data.</p> <p>Most applications will want to create a single <code>JSONPathEnvironment</code>, or use <code>jsonpath.compile()</code>, <code>jsonpath.findall()</code>, etc. from the package-level default environment.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment--environment-customization","title":"Environment customization","text":"<p>Environment customization is achieved by subclassing <code>JSONPathEnvironment</code> and overriding class attributes and/or methods. Some of these customizations include:</p> <ul> <li>Changing the root (<code>$</code>), self (<code>@</code>) or filter context (<code>_</code>) token with   class attributes <code>root_token</code>, <code>self_token</code> and <code>filter_context_token</code>.</li> <li>Registering a custom lexer or parser with the class attributes   <code>lexer_class</code> or <code>parser_class</code>. <code>lexer_class</code> must be a subclass of   <code>Lexer</code> and <code>parser_class</code> must be a subclass of <code>Parser</code>.</li> <li>Setup built-in function extensions by overriding   <code>setup_function_extensions()</code></li> <li>Hook in to mapping and sequence item getting by overriding <code>getitem()</code>.</li> <li>Change filter comparison operator behavior by overriding <code>compare()</code>.</li> </ul> PARAMETER DESCRIPTION <code>filter_caching</code> <p>If <code>True</code>, filter expressions will be cached where possible.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, decode UTF-16 escape sequences found in JSONPath string literals.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>well_typed</code> <p>Control well-typedness checks on filter function expressions. If <code>True</code> (the default), JSONPath expressions are checked for well-typedness as compile time.</p> <p>New in version 0.10.0</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>strict</code> <p>When <code>True</code>, follow RFC 9535 strictly. New in version 2.0.0</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/#jsonpath.JSONPathEnvironment--class-attributes","title":"Class attributes","text":"ATTRIBUTE DESCRIPTION <code>pseudo_root_token</code> <p>The pattern used to select a \"fake\" root node, one level above the real root node.</p> <p> TYPE: <code>str</code> </p> <code>filter_context_token</code> <p>The pattern used to select extra filter context data. Defaults to <code>\"_\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>intersection_token</code> <p>The pattern used as the intersection operator. Defaults to <code>\"&amp;\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>key_token</code> <p>The pattern used to identify the current key or index when filtering a mapping or sequence. Defaults to <code>\"#\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>keys_selector_token</code> <p>The pattern used as the \"keys\" selector. Defaults to <code>\"~\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>keys_filter_token</code> <p>The pattern used as the \"keys filter\" selector. Defaults to <code>\"~?\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>lexer_class</code> <p>The lexer to use when tokenizing path strings.</p> <p> TYPE: <code>Type[Lexer]</code> </p> <code>max_int_index</code> <p>The maximum integer allowed when selecting array items by index. Defaults to <code>(2**53) - 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>min_int_index</code> <p>The minimum integer allowed when selecting array items by index. Defaults to <code>-(2**53) + 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>max_recursion_depth</code> <p>The maximum number of dict/objects and/or arrays/ lists the recursive descent selector can visit before a <code>JSONPathRecursionError</code> is thrown.</p> <p> TYPE: <code>int</code> </p> <code>parser_class</code> <p>The parser to use when parsing tokens from the lexer.</p> <p> TYPE: <code>Type[Parser]</code> </p> <code>root_token</code> <p>The pattern used to select the root node in a JSON document. Defaults to <code>\"$\"</code>.</p> <p> TYPE: <code>str</code> </p> <code>self_token</code> <p>The pattern used to select the current node in a JSON document. Defaults to <code>\"@\"</code></p> <p> TYPE: <code>str</code> </p> <code>union_token</code> <p>The pattern used as the union operator. Defaults to <code>\"|\"</code>.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/#jsonpath.JSONPathEnvironment.filter_caching","title":"filter_caching  <code>instance-attribute</code>","text":"<pre><code>filter_caching: bool = filter_caching\n</code></pre> <p>Enable or disable filter expression caching.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.function_extensions","title":"function_extensions  <code>instance-attribute</code>","text":"<pre><code>function_extensions: Dict[str, Callable[..., Any]] = {}\n</code></pre> <p>A list of function extensions available to filters.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.iregexp_available","title":"iregexp_available  <code>instance-attribute</code>","text":"<pre><code>iregexp_available: bool = IREGEXP_AVAILABLE\n</code></pre> <p>When <code>True</code>, the iregexp_check package is available.</p> <p>iregexp_check will be used to validate regular expressions against RFC 9485, if available.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.lexer","title":"lexer  <code>instance-attribute</code>","text":"<pre><code>lexer: Lexer = lexer_class(env=self)\n</code></pre> <p>The lexer bound to this environment.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.parser","title":"parser  <code>instance-attribute</code>","text":"<pre><code>parser: Parser = parser_class(env=self)\n</code></pre> <p>The parser bound to this environment.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.regex_available","title":"regex_available  <code>instance-attribute</code>","text":"<pre><code>regex_available: bool = REGEX_AVAILABLE\n</code></pre> <p>When <code>True</code>, the third party <code>regex</code> package is available.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict: bool = strict\n</code></pre> <p>When <code>True</code>, follow RFC 9535 strictly.</p> <p>This includes things like enforcing a leading root identifier and ensuring there's no leading or trailing whitespace when parsing a JSONPath query.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.unicode_escape","title":"unicode_escape  <code>instance-attribute</code>","text":"<pre><code>unicode_escape: bool = unicode_escape\n</code></pre> <p>Enable or disable decoding of UTF-16 escape sequences found in JSONPath string literals.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.well_typed","title":"well_typed  <code>instance-attribute</code>","text":"<pre><code>well_typed: bool = well_typed\n</code></pre> <p>Control well-typedness checks on filter function expressions.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.check_well_typedness","title":"check_well_typedness","text":"<pre><code>check_well_typedness(\n    token: Token,\n    func: FilterFunction,\n    args: List[BaseExpression],\n) -&gt; None\n</code></pre> <p>Check the well-typedness of a function's arguments at compile-time.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.compare","title":"compare","text":"<pre><code>compare(left: object, operator: str, right: object) -&gt; bool\n</code></pre> <p>Object comparison within JSONPath filters.</p> <p>Override this to customize filter expression comparison operator behavior.</p> PARAMETER DESCRIPTION <code>left</code> <p>The left hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> <code>operator</code> <p>The comparison expression's operator.</p> <p> TYPE: <code>str</code> </p> <code>right</code> <p>The right hand side of the comparison expression.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the comparison between left and right, with the</p> <code>bool</code> <p>given operator, is truthy. <code>False</code> otherwise.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.compile","title":"compile","text":"<pre><code>compile(path: str) -&gt; Union[JSONPath, CompoundJSONPath]\n</code></pre> <p>Prepare a path string ready for repeated matching against different data.</p> PARAMETER DESCRIPTION <code>path</code> <p>A JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Union[JSONPath, CompoundJSONPath]</code> <p>A <code>JSONPath</code> or <code>CompoundJSONPath</code>, ready to match against some data. Expect a <code>CompoundJSONPath</code> if the path string uses the union or intersection operators.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If path is invalid.</p> <code>JSONPathTypeError</code> <p>If filter functions are given arguments of an unacceptable type.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.findall","title":"findall","text":"<pre><code>findall(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in data matching the JSONPath path.</p> <p>If data is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.finditer","title":"finditer","text":"<pre><code>finditer(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match of path in data.</p> <p>If data is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.getitem","title":"getitem","text":"<pre><code>getitem(obj: Any, key: Any) -&gt; Any\n</code></pre> <p>Sequence and mapping item getter used throughout JSONPath resolution.</p> <p>The default implementation of <code>getitem</code> simply calls <code>operators.getitem()</code> from Python's standard library. Same as <code>obj[key]</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>A mapping or sequence that might contain key.</p> <p> TYPE: <code>Any</code> </p> <code>key</code> <p>A mapping key, sequence index or sequence slice.</p> <p> TYPE: <code>Any</code> </p>"},{"location":"api/#jsonpath.JSONPathEnvironment.getitem_async","title":"getitem_async  <code>async</code>","text":"<pre><code>getitem_async(obj: Any, key: object) -&gt; Any\n</code></pre> <p>An async sequence and mapping item getter.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.is_truthy","title":"is_truthy","text":"<pre><code>is_truthy(obj: object) -&gt; bool\n</code></pre> <p>Test for truthiness when evaluating JSONPath filter expressions.</p> <p>In some cases, RFC 9535 requires us to test for existence rather than truthiness. So the default implementation returns <code>True</code> for empty collections and <code>None</code>. The special <code>UNDEFINED</code> object means that obj was missing, as opposed to an explicit <code>None</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>Any object.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the object exists and is not <code>False</code> or <code>0</code>.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.match","title":"match","text":"<pre><code>match(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Union[JSONPathMatch, None]\n</code></pre> <p>Return a <code>JSONPathMatch</code> instance for the first object found in data.</p> <p><code>None</code> is returned if there are no matches.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[JSONPathMatch, None]</code> <p>A <code>JSONPathMatch</code> object for the first match, or <code>None</code> if there were no matches.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.query","title":"query","text":"<pre><code>query(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Query\n</code></pre> <p>Return a <code>Query</code> iterator over matches found by applying path to data.</p> <p><code>Query</code> objects are iterable.</p> <pre><code>for match in jsonpath.query(\"$.foo..bar\", data):\n    ...\n</code></pre> <p>You can skip and limit results with <code>Query.skip()</code> and <code>Query.limit()</code>.</p> <pre><code>matches = (\n    jsonpath.query(\"$.foo..bar\", data)\n    .skip(5)\n    .limit(10)\n)\n\nfor match in matches\n    ...\n</code></pre> <p><code>Query.tail()</code> will get the last n results.</p> <pre><code>for match in jsonpath.query(\"$.foo..bar\", data).tail(5):\n    ...\n</code></pre> <p>Get values for each match using <code>Query.values()</code>.</p> <pre><code>for obj in jsonpath.query(\"$.foo..bar\", data).limit(5).values():\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Query</code> <p>A query iterator.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.setup_function_extensions","title":"setup_function_extensions","text":"<pre><code>setup_function_extensions() -&gt; None\n</code></pre> <p>Initialize function extensions.</p>"},{"location":"api/#jsonpath.JSONPathEnvironment.validate_function_extension_signature","title":"validate_function_extension_signature","text":"<pre><code>validate_function_extension_signature(\n    token: Token, args: List[Any]\n) -&gt; List[Any]\n</code></pre> <p>Compile-time validation of function extension arguments.</p> <p>RFC 9535 requires us to reject paths that use filter functions with too many or too few arguments.</p>"},{"location":"api/#jsonpath.JSONPathMatch","title":"jsonpath.JSONPathMatch","text":"<p>A matched object with a concrete path.</p> ATTRIBUTE DESCRIPTION <code>children</code> <p>Matched child nodes. This will only be populated after all children have been visited, usually by using <code>findall()</code> or <code>list(finditer())</code>.</p> <p> TYPE: <code>List[JSONPathMatch]</code> </p> <code>obj</code> <p>The matched object.</p> <p> TYPE: <code>object</code> </p> <code>parent</code> <p>The immediate parent to this match in the JSON document. If this is the root node, parent will be <code>None</code>.</p> <p> TYPE: <code>Optional[JSONPathMatch]</code> </p> <code>path</code> <p>The canonical string representation of the path to this match.</p> <p> TYPE: <code>str</code> </p> <code>parts</code> <p>The keys, indices and/or slices that make up the path to this match.</p> <p> TYPE: <code>Tuple[PathPart, ...]</code> </p> <code>root</code> <p>A reference to the root node in the JSON document.</p> <p> TYPE: <code>Union[Sequence[Any], Mapping[str, Any]]</code> </p>"},{"location":"api/#jsonpath.JSONPathMatch.value","title":"value  <code>property</code>","text":"<pre><code>value: object\n</code></pre> <p>Return the value associated with this match/node.</p>"},{"location":"api/#jsonpath.JSONPathMatch.add_child","title":"add_child","text":"<pre><code>add_child(*children: JSONPathMatch) -&gt; None\n</code></pre> <p>Append one or more children to this match.</p>"},{"location":"api/#jsonpath.JSONPathMatch.filter_context","title":"filter_context","text":"<pre><code>filter_context() -&gt; FilterContextVars\n</code></pre> <p>Return filter context data for this match.</p>"},{"location":"api/#jsonpath.JSONPathMatch.new_child","title":"new_child","text":"<pre><code>new_child(\n    obj: object, key: Union[int, str]\n) -&gt; JSONPathMatch\n</code></pre> <p>Return a new JSONPathMatch instance with this instance as its parent.</p>"},{"location":"api/#jsonpath.JSONPathMatch.pointer","title":"pointer","text":"<pre><code>pointer() -&gt; JSONPointer\n</code></pre> <p>Return a <code>JSONPointer</code> pointing to this match's path.</p>"},{"location":"api/#jsonpath.JSONPath","title":"jsonpath.JSONPath","text":"<p>A compiled JSONPath ready to be applied to a JSON string or Python object.</p> PARAMETER DESCRIPTION <code>env</code> <p>The <code>JSONPathEnvironment</code> this path is bound to.</p> <p> TYPE: <code>JSONPathEnvironment</code> </p> <code>segments</code> <p>An iterable of <code>JSONPathSegment</code> instances, as generated by a <code>Parser</code>.</p> <p> TYPE: <code>Iterable[JSONPathSegment]</code> </p> <code>pseudo_root</code> <p>Indicates if target JSON values should be wrapped in a single- element array, so as to make the target root value selectable.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> ATTRIBUTE DESCRIPTION <code>env</code> <p>The <code>JSONPathEnvironment</code> this path is bound to.</p> <p> </p> <code>selectors</code> <p>The <code>JSONPathSelector</code> instances that make up this path.</p> <p> </p>"},{"location":"api/#jsonpath.JSONPath.empty","title":"empty","text":"<pre><code>empty() -&gt; bool\n</code></pre> <p>Return <code>True</code> if this path has no selectors.</p>"},{"location":"api/#jsonpath.JSONPath.findall","title":"findall","text":"<pre><code>findall(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will</p> <code>List[object]</code> <p>be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.JSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.JSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.JSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.JSONPath.match","title":"match","text":"<pre><code>match(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Union[JSONPathMatch, None]\n</code></pre> <p>Return a <code>JSONPathMatch</code> instance for the first object found in data.</p> <p><code>None</code> is returned if there are no matches.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[JSONPathMatch, None]</code> <p>A <code>JSONPathMatch</code> object for the first match, or <code>None</code> if there were no matches.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.JSONPath.query","title":"query","text":"<pre><code>query(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Query\n</code></pre> <p>Return a <code>Query</code> iterator over matches found by applying this path to data.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Query</code> <p>A query iterator.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.JSONPath.singular_query","title":"singular_query","text":"<pre><code>singular_query() -&gt; bool\n</code></pre> <p>Return <code>True</code> if this JSONPath query is a singular query.</p>"},{"location":"api/#jsonpath.CompoundJSONPath","title":"jsonpath.CompoundJSONPath","text":"<p>Multiple <code>JSONPath</code>s combined.</p>"},{"location":"api/#jsonpath.CompoundJSONPath.findall","title":"findall","text":"<pre><code>findall(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>Find all objects in <code>data</code> matching the given JSONPath <code>path</code>.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.CompoundJSONPath.findall_async","title":"findall_async  <code>async</code>","text":"<pre><code>findall_async(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; List[object]\n</code></pre> <p>An async version of <code>findall()</code>.</p>"},{"location":"api/#jsonpath.CompoundJSONPath.finditer","title":"finditer","text":"<pre><code>finditer(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match.</p> <p>If <code>data</code> is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.CompoundJSONPath.finditer_async","title":"finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>An async version of <code>finditer()</code>.</p>"},{"location":"api/#jsonpath.CompoundJSONPath.intersection","title":"intersection","text":"<pre><code>intersection(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>Intersection of this path and another path.</p>"},{"location":"api/#jsonpath.CompoundJSONPath.match","title":"match","text":"<pre><code>match(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Union[JSONPathMatch, None]\n</code></pre> <p>Return a <code>JSONPathMatch</code> instance for the first object found in data.</p> <p><code>None</code> is returned if there are no matches.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[JSONPathMatch, None]</code> <p>A <code>JSONPathMatch</code> object for the first match, or <code>None</code> if there were no matches.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.CompoundJSONPath.query","title":"query","text":"<pre><code>query(\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None\n) -&gt; Query\n</code></pre> <p>Return a <code>Query</code> iterator over matches found by applying this path to data.</p> PARAMETER DESCRIPTION <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Query</code> <p>A query iterator.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"api/#jsonpath.CompoundJSONPath.union","title":"union","text":"<pre><code>union(path: JSONPath) -&gt; CompoundJSONPath\n</code></pre> <p>Union of this path and another path.</p>"},{"location":"api/#jsonpath.Query","title":"jsonpath.Query","text":"<p>A fluent API for managing <code>JSONPathMatch</code> iterators.</p> <p>Usually you'll want to use <code>jsonpath.query()</code> or <code>JSONPathEnvironment.query()</code> to create instances of <code>Query</code> rather than instantiating <code>Query</code> directly.</p> PARAMETER DESCRIPTION <code>it</code> <p>A <code>JSONPathMatch</code> iterable, as you'd get from <code>jsonpath.finditer()</code> or <code>JSONPathEnvironment.finditer()</code>.</p> <p> TYPE: <code>Iterable[JSONPathMatch]</code> </p> <p>New in version 1.1.0</p>"},{"location":"api/#jsonpath.Query.drop","title":"drop","text":"<pre><code>drop(n: int) -&gt; Query\n</code></pre> <p>Skip up to n matches from the query iterator.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n &lt; 0.</p>"},{"location":"api/#jsonpath.Query.first","title":"first","text":"<pre><code>first(n: int) -&gt; Query\n</code></pre> <p>Limit the query iterator to at most the first n matches.</p> <p><code>first()</code> is an alias for <code>limit()</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n &lt; 0.</p>"},{"location":"api/#jsonpath.Query.first_one","title":"first_one","text":"<pre><code>first_one() -&gt; Optional[JSONPathMatch]\n</code></pre> <p>Return the first <code>JSONPathMatch</code> or <code>None</code> if there were no matches.</p>"},{"location":"api/#jsonpath.Query.head","title":"head","text":"<pre><code>head(n: int) -&gt; Query\n</code></pre> <p>Limit the query iterator to at most the first n matches.</p> <p><code>head()</code> is an alias for <code>limit()</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n &lt; 0.</p>"},{"location":"api/#jsonpath.Query.items","title":"items","text":"<pre><code>items() -&gt; Iterable[Tuple[str, object]]\n</code></pre> <p>Return an iterable of (path, object) tuples, one for each match.</p>"},{"location":"api/#jsonpath.Query.last","title":"last","text":"<pre><code>last(n: int) -&gt; Query\n</code></pre> <p>Drop up to the last n matches from the iterator.</p> <p><code>last()</code> is an alias for <code>tail()</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n &lt; 0.</p>"},{"location":"api/#jsonpath.Query.last_one","title":"last_one","text":"<pre><code>last_one() -&gt; Optional[JSONPathMatch]\n</code></pre> <p>Return the last <code>JSONPathMatch</code> or <code>None</code> if there were no matches.</p>"},{"location":"api/#jsonpath.Query.limit","title":"limit","text":"<pre><code>limit(n: int) -&gt; Query\n</code></pre> <p>Limit the query iterator to at most n matches.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n &lt; 0.</p>"},{"location":"api/#jsonpath.Query.locations","title":"locations","text":"<pre><code>locations() -&gt; Iterable[str]\n</code></pre> <p>Return an iterable of normalized paths, one for each match.</p>"},{"location":"api/#jsonpath.Query.one","title":"one","text":"<pre><code>one() -&gt; Optional[JSONPathMatch]\n</code></pre> <p>Return the first <code>JSONPathMatch</code> or <code>None</code> if there were no matches.</p> <p><code>one()</code> is an alias for <code>first_one()</code>.</p>"},{"location":"api/#jsonpath.Query.pointers","title":"pointers","text":"<pre><code>pointers() -&gt; Iterable[JSONPointer]\n</code></pre> <p>Return an iterable of JSONPointers, one for each match.</p>"},{"location":"api/#jsonpath.Query.select","title":"select","text":"<pre><code>select(\n    *expressions: Union[str, JSONPath, CompoundJSONPath],\n    projection: Projection = Projection.RELATIVE\n) -&gt; Iterable[object]\n</code></pre> <p>Query projection using relative JSONPaths.</p> PARAMETER DESCRIPTION <code>expressions</code> <p>One or more JSONPath query expressions to select relative to each match in this query iterator.</p> <p> TYPE: <code>Union[str, JSONPath, CompoundJSONPath]</code> DEFAULT: <code>()</code> </p> <code>projection</code> <p>The style of projection used when selecting values. Can be one of <code>Projection.RELATIVE</code>, <code>Projection.ROOT</code> or <code>Projection.FLAT</code>. Defaults to <code>Projection.RELATIVE</code>.</p> <p> TYPE: <code>Projection</code> DEFAULT: <code>RELATIVE</code> </p> RETURNS DESCRIPTION <code>Iterable[object]</code> <p>An iterable of objects built from selecting expressions relative to each match from the current query.</p> <p>New in version 1.2.0</p>"},{"location":"api/#jsonpath.Query.skip","title":"skip","text":"<pre><code>skip(n: int) -&gt; Query\n</code></pre> <p>Skip up to n matches from the query iterator.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n &lt; 0.</p>"},{"location":"api/#jsonpath.Query.tail","title":"tail","text":"<pre><code>tail(n: int) -&gt; Query\n</code></pre> <p>Drop matches up to the last n matches from the iterator.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n &lt; 0.</p>"},{"location":"api/#jsonpath.Query.take","title":"take","text":"<pre><code>take(n: int) -&gt; Query\n</code></pre> <p>Return a new query iterating over the next n matches.</p> <p>It is safe to continue using this query after calling take.</p>"},{"location":"api/#jsonpath.Query.tee","title":"tee","text":"<pre><code>tee(n: int = 2) -&gt; Tuple[Query, ...]\n</code></pre> <p>Return n independent queries by teeing this query's iterator.</p> <p>It is not safe to use a <code>Query</code> instance after calling <code>tee()</code>.</p>"},{"location":"api/#jsonpath.Query.values","title":"values","text":"<pre><code>values() -&gt; Iterable[object]\n</code></pre> <p>Return an iterable of objects associated with each match.</p>"},{"location":"api/#jsonpath.Projection","title":"jsonpath.Projection","text":"<p>               Bases: <code>Enum</code></p> <p>Projection style used by <code>Query.select()</code>.</p>"},{"location":"api/#jsonpath.Projection.FLAT","title":"FLAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FLAT = auto()\n</code></pre> <p>All selections are appended to a new array/list, without arrays and objects on the path to the selected value.</p>"},{"location":"api/#jsonpath.Projection.RELATIVE","title":"RELATIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RELATIVE = auto()\n</code></pre> <p>The default projection. Selections include parent arrays and objects relative to the JSONPathMatch.</p>"},{"location":"api/#jsonpath.Projection.ROOT","title":"ROOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ROOT = auto()\n</code></pre> <p>Selections include parent arrays and objects relative to the root JSON value.</p>"},{"location":"api/#jsonpath.function_extensions.FilterFunction","title":"jsonpath.function_extensions.FilterFunction","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for typed function extensions.</p>"},{"location":"api/#jsonpath.function_extensions.FilterFunction.arg_types","title":"arg_types  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>arg_types: List[ExpressionType]\n</code></pre> <p>Argument types expected by the filter function.</p>"},{"location":"api/#jsonpath.function_extensions.FilterFunction.return_type","title":"return_type  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>return_type: ExpressionType\n</code></pre> <p>The type of the value returned by the filter function.</p>"},{"location":"api/#jsonpath.function_extensions.FilterFunction.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(*args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Called the filter function.</p>"},{"location":"api/#jsonpath.function_extensions.ExpressionType","title":"jsonpath.function_extensions.ExpressionType","text":"<p>               Bases: <code>Enum</code></p> <p>The type of a filter function argument or return value.</p>"},{"location":"api/#jsonpath.JSONPointer","title":"jsonpath.JSONPointer","text":"<p>Identify a single, specific value in JSON-like data, as per RFC 6901.</p> PARAMETER DESCRIPTION <code>pointer</code> <p>A string representation of a JSON Pointer.</p> <p> TYPE: <code>str</code> </p> <code>parts</code> <p>The keys, indices and/or slices that make up a JSON Pointer. If given, it is assumed that the parts have already been parsed by the JSONPath parser. <code>unicode_escape</code> and <code>uri_decode</code> are ignored if parts is given.</p> <p> TYPE: <code>Tuple[Union[int, str], ...]</code> DEFAULT: <code>()</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> ATTRIBUTE DESCRIPTION <code>keys_selector</code> <p>The non-standard token used to target a mapping key or name.</p> <p> TYPE: <code>str</code> </p> <code>max_int_index</code> <p>The maximum integer allowed when resolving array items by index. Defaults to <code>(2**53) - 1</code>.</p> <p> TYPE: <code>int</code> </p> <code>min_int_index</code> <p>The minimum integer allowed when resolving array items by index. Defaults to <code>-(2**53) + 1</code>.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/#jsonpath.JSONPointer.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: object) -&gt; JSONPointer\n</code></pre> <p>Join this pointer with other.</p> <p>other is expected to be a JSON Pointer string, possibly without a leading slash. If other does have a leading slash, the previous pointer is ignored and a new JSONPath is returned from other.</p> <p>other should not be a \"Relative JSON Pointer\".</p>"},{"location":"api/#jsonpath.JSONPointer.exists","title":"exists","text":"<pre><code>exists(\n    data: Union[\n        str, IOBase, Sequence[object], Mapping[str, object]\n    ],\n) -&gt; bool\n</code></pre> <p>Return True if this pointer can be resolved against data.</p> <p>Note that <code>JSONPointer.resolve()</code> can return legitimate falsy values that form part of the target JSON document. This method will return <code>True</code> if a falsy value is found.</p> PARAMETER DESCRIPTION <code>data</code> <p>The target JSON \"document\" or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[object], Mapping[str, object]]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if this pointer can be resolved against data, or False otherwise.</p> <p>New in version 0.9.0</p>"},{"location":"api/#jsonpath.JSONPointer.from_match","title":"from_match  <code>classmethod</code>","text":"<pre><code>from_match(match: JSONPathMatch) -&gt; JSONPointer\n</code></pre> <p>Return a JSON Pointer for the path from a JSONPathMatch instance.</p>"},{"location":"api/#jsonpath.JSONPointer.from_parts","title":"from_parts  <code>classmethod</code>","text":"<pre><code>from_parts(\n    parts: Iterable[Union[int, str]],\n    *,\n    unicode_escape: bool = True,\n    uri_decode: bool = False\n) -&gt; JSONPointer\n</code></pre> <p>Build a JSON Pointer from parts.</p> PARAMETER DESCRIPTION <code>parts</code> <p>The keys, indices and/or slices that make up a JSONPointer.</p> <p> TYPE: <code>Iterable[Union[int, str]]</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>JSONPointer</code> <p>A new <code>JSONPointer</code> built from parts.</p>"},{"location":"api/#jsonpath.JSONPointer.is_relative_to","title":"is_relative_to","text":"<pre><code>is_relative_to(other: JSONPointer) -&gt; bool\n</code></pre> <p>Return True if this pointer points to a child of other.</p>"},{"location":"api/#jsonpath.JSONPointer.join","title":"join","text":"<pre><code>join(*parts: str) -&gt; JSONPointer\n</code></pre> <p>Join this pointer with parts.</p> <p>Each part is expected to be a JSON Pointer string, possibly without a leading slash. If a part does have a leading slash, the previous pointer is ignored and a new <code>JSONPointer</code> is created, and processing of remaining parts continues.</p>"},{"location":"api/#jsonpath.JSONPointer.parent","title":"parent","text":"<pre><code>parent() -&gt; JSONPointer\n</code></pre> <p>Return this pointer's parent, as a new <code>JSONPointer</code>.</p> <p>If this pointer points to the document root, self is returned.</p> <p>New in version 0.9.0</p>"},{"location":"api/#jsonpath.JSONPointer.resolve","title":"resolve","text":"<pre><code>resolve(\n    data: Union[\n        str, IOBase, Sequence[object], Mapping[str, object]\n    ],\n    *,\n    default: object = UNDEFINED\n) -&gt; object\n</code></pre> <p>Resolve this pointer against data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The target JSON \"document\" or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[object], Mapping[str, object]]</code> </p> <code>default</code> <p>A default value to return if the pointer can't be resolved against the given data.</p> <p> TYPE: <code>object</code> DEFAULT: <code>UNDEFINED</code> </p> RETURNS DESCRIPTION <code>object</code> <p>The object in data pointed to by this pointer.</p> RAISES DESCRIPTION <code>JSONPointerIndexError</code> <p>When attempting to access a sequence by an out of range index, unless a default is given.</p> <code>JSONPointerKeyError</code> <p>If any mapping object along the path does not contain a specified key, unless a default is given.</p> <code>JSONPointerTypeError</code> <p>When attempting to resolve a non-index string path part against a sequence, unless a default is given.</p>"},{"location":"api/#jsonpath.JSONPointer.resolve_parent","title":"resolve_parent","text":"<pre><code>resolve_parent(\n    data: Union[\n        str, IOBase, Sequence[object], Mapping[str, object]\n    ],\n) -&gt; Tuple[\n    Union[Sequence[object], Mapping[str, object], None],\n    object,\n]\n</code></pre> <p>Resolve this pointer against data, return the object and its parent.</p> PARAMETER DESCRIPTION <code>data</code> <p>The target JSON \"document\" or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, Sequence[object], Mapping[str, object]]</code> </p> RETURNS DESCRIPTION <code>Tuple[Union[Sequence[object], Mapping[str, object], None], object]</code> <p>A <code>(parent, object)</code> tuple, where parent will be <code>None</code> if this pointer points to the root node in the document. If the parent exists but the last object does not, <code>(parent, UNDEFINED)</code> will be returned.</p> RAISES DESCRIPTION <code>JSONPointerIndexError</code> <p>When attempting to access a sequence by an out of range index, unless using the special <code>-</code> index.</p> <code>JSONPointerKeyError</code> <p>If any mapping object along the path does not contain a specified key, unless it is the last part of the pointer.</p> <code>JSONPointerTypeError</code> <p>When attempting to resolve a non-index string path part against a sequence.</p>"},{"location":"api/#jsonpath.JSONPointer.to","title":"to","text":"<pre><code>to(\n    rel: Union[RelativeJSONPointer, str],\n    *,\n    unicode_escape: bool = True,\n    uri_decode: bool = False\n) -&gt; JSONPointer\n</code></pre> <p>Return a new pointer relative to this pointer.</p> PARAMETER DESCRIPTION <code>rel</code> <p>A <code>RelativeJSONPointer</code> or a string following \"Relative JSON Pointer\" syntax.</p> <p> TYPE: <code>Union[RelativeJSONPointer, str]</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>See https://www.ietf.org/id/draft-hha-relative-json-pointer-00.html</p>"},{"location":"api/#jsonpath.RelativeJSONPointer","title":"jsonpath.RelativeJSONPointer","text":"<p>A Relative JSON Pointer.</p> <p>See https://www.ietf.org/id/draft-hha-relative-json-pointer-00.html</p> PARAMETER DESCRIPTION <code>rel</code> <p>A string following Relative JSON Pointer syntax.</p> <p> TYPE: <code>str</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/#jsonpath.RelativeJSONPointer.to","title":"to","text":"<pre><code>to(\n    pointer: Union[JSONPointer, str],\n    *,\n    unicode_escape: bool = True,\n    uri_decode: bool = False\n) -&gt; JSONPointer\n</code></pre> <p>Return a new JSONPointer relative to pointer.</p> PARAMETER DESCRIPTION <code>pointer</code> <p>A <code>JSONPointer</code> instance or a string following JSON Pointer syntax.</p> <p> TYPE: <code>Union[JSONPointer, str]</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing the pointer.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, the pointer will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/#jsonpath.JSONPatch","title":"jsonpath.JSONPatch","text":"<p>Modify JSON-like data with JSON Patch.</p> <p>RFC 6902 defines operations to manipulate a JSON document. <code>JSONPatch</code> supports parsing and applying standard JSON Patch formatted operations, and provides a Python builder API following the same semantics as RFC 6902.</p> PARAMETER DESCRIPTION <code>ops</code> <p>A JSON Patch formatted document or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, Iterable[Mapping[str, object]], None]</code> DEFAULT: <code>None</code> </p> <code>unicode_escape</code> <p>If <code>True</code>, UTF-16 escape sequences will be decoded before parsing JSON pointers.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>uri_decode</code> <p>If <code>True</code>, JSON pointers will be unescaped using urllib before being parsed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>JSONPatchError</code> <p>If ops is given and any of the provided operations is malformed.</p>"},{"location":"api/#jsonpath.JSONPatch.add","title":"add","text":"<pre><code>add(path: Union[str, JSONPointer], value: object) -&gt; Self\n</code></pre> <p>Append an add operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>value</code> <p>The object to add.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.JSONPatch.addap","title":"addap","text":"<pre><code>addap(path: Union[str, JSONPointer], value: object) -&gt; Self\n</code></pre> <p>Append an addap operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>value</code> <p>The object to add.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.JSONPatch.addne","title":"addne","text":"<pre><code>addne(path: Union[str, JSONPointer], value: object) -&gt; Self\n</code></pre> <p>Append an addne operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>value</code> <p>The object to add.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.JSONPatch.apply","title":"apply","text":"<pre><code>apply(\n    data: Union[\n        str,\n        IOBase,\n        MutableSequence[object],\n        MutableMapping[str, object],\n    ],\n) -&gt; object\n</code></pre> <p>Apply all operations from this patch to data.</p> <p>If data is a string or file-like object, it will be loaded with json.loads. Otherwise data should be a JSON-like data structure and will be modified in place.</p> <p>When modifying data in place, we return modified data too. This is to allow for replacing data's root element, which is allowed by some patch operations.</p> PARAMETER DESCRIPTION <code>data</code> <p>The target JSON \"document\" or equivalent Python objects.</p> <p> TYPE: <code>Union[str, IOBase, MutableSequence[object], MutableMapping[str, object]]</code> </p> RETURNS DESCRIPTION <code>object</code> <p>Modified input data.</p> RAISES DESCRIPTION <code>JSONPatchError</code> <p>When a patch operation fails.</p> <code>JSONPatchTestFailure</code> <p>When a test operation does not pass. <code>JSONPatchTestFailure</code> is a subclass of <code>JSONPatchError</code>.</p>"},{"location":"api/#jsonpath.JSONPatch.asdicts","title":"asdicts","text":"<pre><code>asdicts() -&gt; List[Dict[str, object]]\n</code></pre> <p>Return a list of this patch's operations as dictionaries.</p>"},{"location":"api/#jsonpath.JSONPatch.copy","title":"copy","text":"<pre><code>copy(\n    from_: Union[str, JSONPointer],\n    path: Union[str, JSONPointer],\n) -&gt; Self\n</code></pre> <p>Append a copy operation to this patch.</p> PARAMETER DESCRIPTION <code>from_</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.JSONPatch.move","title":"move","text":"<pre><code>move(\n    from_: Union[str, JSONPointer],\n    path: Union[str, JSONPointer],\n) -&gt; Self\n</code></pre> <p>Append a move operation to this patch.</p> PARAMETER DESCRIPTION <code>from_</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.JSONPatch.remove","title":"remove","text":"<pre><code>remove(path: Union[str, JSONPointer]) -&gt; Self\n</code></pre> <p>Append a remove operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.JSONPatch.replace","title":"replace","text":"<pre><code>replace(\n    path: Union[str, JSONPointer], value: object\n) -&gt; Self\n</code></pre> <p>Append a replace operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>value</code> <p>The object to add.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"api/#jsonpath.JSONPatch.test","title":"test","text":"<pre><code>test(path: Union[str, JSONPointer], value: object) -&gt; Self\n</code></pre> <p>Append a test operation to this patch.</p> PARAMETER DESCRIPTION <code>path</code> <p>A string representation of a JSON Pointer, or one that has already been parsed.</p> <p> TYPE: <code>Union[str, JSONPointer]</code> </p> <code>value</code> <p>The object to test.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This <code>JSONPatch</code> instance, so we can build a JSON Patch by chaining calls to JSON Patch operation methods.</p>"},{"location":"async/","title":"Async API","text":"<p>Largely motivated by its integration with Python Liquid, Python JSONPath offers an asynchronous API that allows for items in a target data structure to be \"fetched\" lazily.</p> <p><code>findall_async()</code> and <code>finditer_async()</code> are asyncio equivalents to <code>findall()</code> and <code>finditer()</code>. By default, any class implementing the mapping or sequence interfaces, and a <code>__getitem_async__()</code> method, will have <code>__getitem_async__()</code> awaited instead of calling <code>__getitem__()</code> when resolving mapping keys or sequence indices.</p>"},{"location":"async/#example","title":"Example","text":"<p>In this example, showing a lazy-loading collections of <code>Player</code> objects, only the \"A\" team's players are fetched from the database, and only when they are first accessed.</p> <pre><code>from collections import abc\nfrom dataclasses import dataclass\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\n\nimport jsonpath\n\n\n@dataclass\nclass Player:\n    name: str\n    pid: int\n    rank: int\n\n\nclass LazyPlayers(abc.Mapping[str, Player]):\n    def __init__(self, names: List[str]):\n        self.names = names\n        self.cached_players: Dict[str, Player] = {}\n\n    def __len__(self) -&gt; int:\n        return len(self.names)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.names)\n\n    def __getitem__(self, k: str) -&gt; Player:\n        if self.cached_players is None:\n            # Blocking IO here\n            self.cached_players = get_stuff_from_database()\n        return self.cached_players[k]\n\n    async def __getitem_async__(self, k: str) -&gt; Player:\n        if self.cached_players is None:\n            # Do async IO here.\n            self.cached_players = await get_stuff_from_database_async()\n        return self.cached_players[k]\n\n\ndata = {\n    \"teams\": {\n        \"A Team\": LazyPlayers([\"Sue\", \"Bob\"]),\n        \"B Team\": LazyPlayers([\"Sally\", \"Frank\"]),\n    }\n}\n\nbest_a_team_players = jsonpath.findall_async(\"$.teams['A Team'][?rank &gt;= 8]\", data)\n</code></pre>"},{"location":"cli/","title":"Command Line Interface","text":"<p>New in version 0.9.0</p> <p>Python JSONPath includes a script called <code>json</code>, exposing JSONPath, JSON Pointer and JSON Patch features on the command line. Use the <code>--version</code> argument to check the current version of Python JSONPath, and the <code>--help</code> argument to display command information.</p> <pre><code>$ json --version\npython-jsonpath, version 0.9.0\n</code></pre> <pre><code>$ json --help\nusage: json [-h] [--debug] [--pretty] [-v] [--no-unicode-escape] COMMAND ...\n\nJSONPath, JSON Pointer and JSON Patch utilities.\n\npositional arguments:\n  COMMAND\n    path               Find objects in a JSON document given a JSONPath.\n    pointer            Resolve a JSON Pointer against a JSON document.\n    patch              Apply a JSON Patch to a JSON document.\n\noptional arguments:\n  -h, --help           show this help message and exit\n  --debug              Show stack traces. (default: False)\n  --pretty             Add indents and newlines to output JSON. (default: False)\n  -v, --version        Show the version and exit.\n  --no-unicode-escape  Disable decoding of UTF-16 escape sequence within paths and pointers. (default:\n                       False)\n\nUse [json COMMAND --help] for command specific help.\n\nUsage Examples:\n  Find objects in source.json matching a JSONPath, write them to result.json.\n  $ json path -q \"$.foo['bar'][?@.baz &gt; 1]\" -f source.json -o result.json\n\n  Resolve a JSON Pointer against source.json, pretty print the result to stdout.\n  $ json --pretty pointer -p \"/foo/bar/0\" -f source.json\n\n  Apply JSON Patch patch.json to JSON from stdin, output to result.json.\n  $ cat source.json | json patch /path/to/patch.json -o result.json\n</code></pre> <p>Use <code>json COMMAND --help</code> for command specific help.</p> <pre><code>$ json path --help\nusage: json path [-h] (-q QUERY | -r PATH_FILE) [-f FILE] [-o OUTPUT]\n\nFind objects in a JSON document given a JSONPath.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -q QUERY, --query QUERY\n                        JSONPath query string.\n  -r PATH_FILE, --path-file PATH_FILE\n                        Text file containing a JSONPath query.\n  -f FILE, --file FILE  File to read the target JSON document from. Defaults to reading from the\n                        standard input stream.\n  -o OUTPUT, --output OUTPUT\n                        File to write resulting objects to, as a JSON array. Defaults to the standard\n                        output stream.\n  --no-type-checks      Disables filter expression well-typedness checks.\n  --strict              Compile and evaluate JSONPath expressions with strict compliance with RFC 9535.\n</code></pre>"},{"location":"cli/#global-options","title":"Global Options","text":"<p>These arguments apply to any subcommand and must be listed before the command.</p>"},{"location":"cli/#-debug","title":"<code>--debug</code>","text":"<p>Enable debugging. Display full stack traces, if available, when errors occur. Without the <code>--debug</code> option, the following example shows a short \"json path syntax error\" message.</p> <pre><code>$ json path -q \"$.1\" -f /tmp/source.json\njson path syntax error: unexpected token '1', line 1, column 2\n</code></pre> <p>With the <code>--debug</code> option, we get the stack trace triggered by <code>JSONPathSyntaxError</code>.</p> <pre><code>$ json --debug path -q \"$.1\" -f /tmp/source.json\nTraceback (most recent call last):\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/bin/json\", line 8, in &lt;module&gt;\n    sys.exit(main())\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/cli.py\", line 338, in main\n    args.func(args)\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/cli.py\", line 234, in handle_path_command\n    path = jsonpath.compile(args.query or args.path_file.read())\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/env.py\", line 148, in compile\n    _path: Union[JSONPath, CompoundJSONPath] = JSONPath(\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/path.py\", line 49, in __init__\n    self.selectors = tuple(selectors)\n  File \"/home/james/.local/share/virtualenvs/jsonpath_cli-8Tb3e-ir/lib/python3.9/site-packages/jsonpath/parse.py\", line 256, in parse\n    raise JSONPathSyntaxError(\njsonpath.exceptions.JSONPathSyntaxError: unexpected token '1', line 1, column 2\n</code></pre>"},{"location":"cli/#-pretty","title":"<code>--pretty</code>","text":"<p>Enable pretty formatting when outputting JSON. Adds newlines and indentation to output specified with the <code>-o</code> or <code>--output</code> option. Without the <code>--pretty</code> option, the following example output is on one line.</p> <pre><code>$ json pointer -p \"/categories/1/products/0\" -f /tmp/source.json\n{\"title\": \"Cap\", \"description\": \"Baseball cap\", \"price\": 15.0}\n</code></pre> <p>With the <code>--pretty</code> option, we get nicely formatted JSON output.</p> <pre><code>$ json --pretty pointer -p \"/categories/1/products/0\" -f /tmp/source.json\n{\n  \"title\": \"Cap\",\n  \"description\": \"Baseball cap\",\n  \"price\": 15.0\n}\n</code></pre>"},{"location":"cli/#-no-unicode-escape","title":"<code>--no-unicode-escape</code>","text":"<p>Disable decoding of UTF-16 escape sequences, including surrogate paris. This can improve performance if you know your paths and pointers don't contain UTF-16 escape sequences.</p> <pre><code>$ json --no-unicode-escape path -q \"$.price_cap\" -f /tmp/source.json\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":"<p>One of the subcommands <code>path</code>, <code>pointer</code> or <code>patch</code> must be specified, depending on whether you want to search a JSON document with a JSONPath, resolve a JSON Pointer against a JSON document or apply a JSON Patch to a JSON Document.</p>"},{"location":"cli/#path","title":"<code>path</code>","text":"<p>Find objects in a JSON document given a JSONPath. One of <code>-q</code>/<code>--query</code> or <code>-r</code>/<code>--path-file</code> must be given. <code>-q</code> being a JSONPath given on the command line as a string, <code>-r</code> being the path to a file containing a JSONPath.</p> <pre><code>json path [-h] (-q QUERY | -r PATH_FILE) [-f FILE] [-o OUTPUT]\n</code></pre>"},{"location":"cli/#-q-query","title":"<code>-q</code> / <code>--query</code>","text":"<p>The JSONPath as a string.</p> <pre><code>$ json path -q \"$.price_cap\" -f /tmp/source.json\n</code></pre> <pre><code>$ json path --query \"$.price_cap\" -f /tmp/source.json\n</code></pre>"},{"location":"cli/#-r-path-file","title":"<code>-r</code> / <code>--path-file</code>","text":"<p>The path to a file containing a JSONPath.</p> <pre><code>$ json path -r /tmp/path.txt -f /tmp/source.json\n</code></pre> <pre><code>$ json path --path-file /tmp/path.txt -f /tmp/source.json\n</code></pre>"},{"location":"cli/#-f-file","title":"<code>-f</code> / <code>--file</code>","text":"<p>The path to a file containing the target JSON document. If omitted or a hyphen (<code>-</code>), the target JSON document will be read from the standard input stream.</p> <pre><code>$ json path -q \"$.price_cap\" -f /tmp/source.json\n</code></pre> <pre><code>$ json path -q \"$.price_cap\" --file /tmp/source.json\n</code></pre>"},{"location":"cli/#-o-output","title":"<code>-o</code> / <code>--output</code>","text":"<p>The path to a file to write resulting objects to, as a JSON array. If omitted or a hyphen (<code>-</code>) is given, results will be written to the standard output stream.</p> <pre><code>$ json path -q \"$.price_cap\" -f /tmp/source.json -o result.json\n</code></pre> <pre><code>$ json path -q \"$.price_cap\" -f /tmp/source.json --output result.json\n</code></pre>"},{"location":"cli/#-no-type-checks","title":"<code>--no-type-checks</code>","text":"<p>New in version 0.10.0</p> <p>Disables JSONPath filter expression well-typedness checks. The well-typedness of a filter expression is defined by RFC 9535.</p>"},{"location":"cli/#-strict","title":"<code>--strict</code>","text":"<p>New in version 2.0.0</p> <p>Compile and evaluate JSONPath expressions with strict compliance with RFC 9535.</p>"},{"location":"cli/#pointer","title":"<code>pointer</code>","text":"<p>Resolve a JSON Pointer against a JSON document. One of <code>-p</code>/<code>--pointer</code> or <code>-r</code>/<code>--pointer-file</code> must be given. <code>-p</code> being a JSON Pointer given on the command line as a string, <code>-r</code> being the path to a file containing a JSON Pointer.</p> <pre><code>json pointer [-h] (-p POINTER | -r POINTER_FILE) [-f FILE] [-o OUTPUT] [-u]\n</code></pre>"},{"location":"cli/#-p-pointer","title":"<code>-p</code> / <code>--pointer</code>","text":"<p>An RFC 6901 formatted JSON Pointer string.</p> <pre><code>$ json pointer -p \"/categories/0/name\" -f /tmp/source.json\n</code></pre> <pre><code>$ json pointer --pointer \"/categories/0/name\" -f /tmp/source.json\n</code></pre>"},{"location":"cli/#-r-pointer-file","title":"<code>-r</code> / <code>--pointer-file</code>","text":"<p>The path to a file containing a JSON Pointer.</p> <pre><code>$ json pointer -r /tmp/pointer.txt -f /tmp/source.json\n</code></pre> <pre><code>$ json pointer --pointer-file /tmp/pointer.txt -f /tmp/source.json\n</code></pre>"},{"location":"cli/#-f-file_1","title":"<code>-f</code> / <code>--file</code>","text":"<p>The path to a file containing the target JSON document. If omitted or a hyphen (<code>-</code>), the target JSON document will be read from the standard input stream.</p> <pre><code>$ json pointer -p \"/categories/0/name\" -f /tmp/source.json\n</code></pre> <pre><code>$ json pointer -p \"/categories/0/name\" --file /tmp/source.json\n</code></pre>"},{"location":"cli/#-o-output_1","title":"<code>-o</code> / <code>--output</code>","text":"<p>The path to a file to write the resulting object to. If omitted or a hyphen (<code>-</code>) is given, results will be written to the standard output stream.</p> <pre><code>$ json pointer -p \"/categories/0/name\" -f /tmp/source.json -o result.json\n</code></pre> <pre><code>$ json pointer -p \"/categories/0/name\" -f /tmp/source.json --output result.json\n</code></pre>"},{"location":"cli/#-u-uri-decode","title":"<code>-u</code> / <code>--uri-decode</code>","text":"<p>Enable URI decoding of the JSON Pointer. In this example, we would look for a property called \"hello world\" in the root of the target document.</p> <pre><code>$ json pointer -p \"/hello%20world\" -f /tmp/source.json -u\n</code></pre> <pre><code>$ json pointer -p \"/hello%20world\" -f /tmp/source.json --uri-decode\n</code></pre>"},{"location":"cli/#patch","title":"<code>patch</code>","text":"<p>Apply a JSON Patch to a JSON document. Unlike <code>path</code> and <code>pointer</code> commands, a patch can't be given as a string argument. <code>PATCH</code> is a positional argument that should be a file path to a JSON Patch document or a hyphen (<code>-</code>), which means the patch document will be read from the standard input stream.</p> <pre><code>json patch [-h] [-f FILE] [-o OUTPUT] [-u] PATCH\n</code></pre> <p>These examples read the patch from <code>patch.json</code> and the document to modify from <code>target.json</code></p> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json\n</code></pre> <pre><code>$ cat /tmp/patch.json | json patch - -f /tmp/target.json\n</code></pre>"},{"location":"cli/#-f-file_2","title":"<code>-f</code> / <code>--file</code>","text":"<p>The path to a file containing the target JSON document. If omitted or a hyphen (<code>-</code>), the target JSON document will be read from the standard input stream.</p> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json\n</code></pre> <pre><code>$ json patch /tmp/patch.json --file /tmp/target.json\n</code></pre>"},{"location":"cli/#-o-output_2","title":"<code>-o</code> / <code>--output</code>","text":"<p>The path to a file to write the resulting object to. If omitted or a hyphen (<code>-</code>) is given, results will be written to the standard output stream.</p> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json -o result.json\n</code></pre> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json --output result.json\n</code></pre>"},{"location":"cli/#-u-uri-decode_1","title":"<code>-u</code> / <code>--uri-decode</code>","text":"<p>Enable URI decoding of JSON Pointers in the patch document.</p> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json -u\n</code></pre> <pre><code>$ json patch /tmp/patch.json -f /tmp/target.json --uri-decode\n</code></pre>"},{"location":"convenience/","title":"Convenience Functions","text":"<p>These package-level functions use the default JSONPathEnvironment, <code>jsonpath.DEFAULT_ENV</code> when <code>strict=False</code>, or the preconfigured strict environment, <code>jsonpath.STRICT_ENV</code> when <code>strict=True</code>.</p>"},{"location":"convenience/#jsonpath.compile","title":"jsonpath.compile","text":"<pre><code>compile(\n    path: str, *, strict: bool = False\n) -&gt; Union[JSONPath, CompoundJSONPath]\n</code></pre> <p>Prepare a path string ready for repeated matching against different data.</p> PARAMETER DESCRIPTION <code>path</code> <p>A JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>strict</code> <p>When <code>True</code>, compile the path for strict compliance with RFC 9535.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Union[JSONPath, CompoundJSONPath]</code> <p>A <code>JSONPath</code> or <code>CompoundJSONPath</code>, ready to match against some data. Expect a <code>CompoundJSONPath</code> if the path string uses the union or intersection operators.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If path is invalid.</p> <code>JSONPathTypeError</code> <p>If filter functions are given arguments of an unacceptable type.</p>"},{"location":"convenience/#jsonpath.findall","title":"jsonpath.findall","text":"<pre><code>findall(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None,\n    strict: bool = False\n) -&gt; List[object]\n</code></pre> <p>Find all objects in data matching the JSONPath path.</p> <p>If data is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>When <code>True</code>, compile and evaluate with strict compliance with RFC 9535.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"convenience/#jsonpath.finditer","title":"jsonpath.finditer","text":"<pre><code>finditer(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None,\n    strict: bool = False\n) -&gt; Iterable[JSONPathMatch]\n</code></pre> <p>Generate <code>JSONPathMatch</code> objects for each match of path in data.</p> <p>If data is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>When <code>True</code>, compile and evaluate with strict compliance with RFC 9535.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Iterable[JSONPathMatch]</code> <p>An iterator yielding <code>JSONPathMatch</code> objects for each match.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"convenience/#jsonpath.findall_async","title":"jsonpath.findall_async  <code>async</code>","text":"<pre><code>findall_async(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None,\n    strict: bool = False\n) -&gt; List[object]\n</code></pre> <p>Find all objects in data matching the JSONPath path.</p> <p>If data is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>When <code>True</code>, compile and evaluate with strict compliance with RFC 9535.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>List[object]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"convenience/#jsonpath.finditer_async","title":"jsonpath.finditer_async  <code>async</code>","text":"<pre><code>finditer_async(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None,\n    strict: bool = False\n) -&gt; AsyncIterable[JSONPathMatch]\n</code></pre> <p>Find all objects in data matching the JSONPath path.</p> <p>If data is a string or a file-like objects, it will be loaded using <code>json.loads()</code> and the default <code>JSONDecoder</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>When <code>True</code>, compile and evaluate with strict compliance with RFC 9535.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>AsyncIterable[JSONPathMatch]</code> <p>A list of matched objects. If there are no matches, the list will be empty.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"convenience/#jsonpath.match","title":"jsonpath.match","text":"<p>The JSONPath match object, as returned from <code>JSONPath.finditer()</code>.</p>"},{"location":"convenience/#jsonpath.match.JSONPathMatch","title":"JSONPathMatch","text":"<p>A matched object with a concrete path.</p> ATTRIBUTE DESCRIPTION <code>children</code> <p>Matched child nodes. This will only be populated after all children have been visited, usually by using <code>findall()</code> or <code>list(finditer())</code>.</p> <p> TYPE: <code>List[JSONPathMatch]</code> </p> <code>obj</code> <p>The matched object.</p> <p> TYPE: <code>object</code> </p> <code>parent</code> <p>The immediate parent to this match in the JSON document. If this is the root node, parent will be <code>None</code>.</p> <p> TYPE: <code>Optional[JSONPathMatch]</code> </p> <code>path</code> <p>The canonical string representation of the path to this match.</p> <p> TYPE: <code>str</code> </p> <code>parts</code> <p>The keys, indices and/or slices that make up the path to this match.</p> <p> TYPE: <code>Tuple[PathPart, ...]</code> </p> <code>root</code> <p>A reference to the root node in the JSON document.</p> <p> TYPE: <code>Union[Sequence[Any], Mapping[str, Any]]</code> </p>"},{"location":"convenience/#jsonpath.match.JSONPathMatch.value","title":"value  <code>property</code>","text":"<pre><code>value: object\n</code></pre> <p>Return the value associated with this match/node.</p>"},{"location":"convenience/#jsonpath.match.JSONPathMatch.add_child","title":"add_child","text":"<pre><code>add_child(*children: JSONPathMatch) -&gt; None\n</code></pre> <p>Append one or more children to this match.</p>"},{"location":"convenience/#jsonpath.match.JSONPathMatch.filter_context","title":"filter_context","text":"<pre><code>filter_context() -&gt; FilterContextVars\n</code></pre> <p>Return filter context data for this match.</p>"},{"location":"convenience/#jsonpath.match.JSONPathMatch.new_child","title":"new_child","text":"<pre><code>new_child(\n    obj: object, key: Union[int, str]\n) -&gt; JSONPathMatch\n</code></pre> <p>Return a new JSONPathMatch instance with this instance as its parent.</p>"},{"location":"convenience/#jsonpath.match.JSONPathMatch.pointer","title":"pointer","text":"<pre><code>pointer() -&gt; JSONPointer\n</code></pre> <p>Return a <code>JSONPointer</code> pointing to this match's path.</p>"},{"location":"convenience/#jsonpath.match.NodeList","title":"NodeList","text":"<p>               Bases: <code>List[JSONPathMatch]</code></p> <p>List of JSONPathMatch objects, analogous to the spec's nodelist.</p>"},{"location":"convenience/#jsonpath.match.NodeList.empty","title":"empty","text":"<pre><code>empty() -&gt; bool\n</code></pre> <p>Return <code>True</code> if this node list is empty.</p>"},{"location":"convenience/#jsonpath.match.NodeList.paths","title":"paths","text":"<pre><code>paths() -&gt; List[str]\n</code></pre> <p>Return a normalized path for each node in this node list.</p>"},{"location":"convenience/#jsonpath.match.NodeList.values","title":"values","text":"<pre><code>values() -&gt; List[object]\n</code></pre> <p>Return the values from this node list.</p>"},{"location":"convenience/#jsonpath.match.NodeList.values_or_singular","title":"values_or_singular","text":"<pre><code>values_or_singular() -&gt; object\n</code></pre> <p>Return the values from this node list.</p>"},{"location":"convenience/#jsonpath.query","title":"jsonpath.query","text":"<pre><code>query(\n    path: str,\n    data: JSONData,\n    *,\n    filter_context: Optional[FilterContextVars] = None,\n    strict: bool = False\n) -&gt; Query\n</code></pre> <p>Return a <code>Query</code> iterator over matches found by applying path to data.</p> <p><code>Query</code> objects are iterable.</p> <pre><code>for match in jsonpath.query(\"$.foo..bar\", data):\n    ...\n</code></pre> <p>You can skip and limit results with <code>Query.skip()</code> and <code>Query.limit()</code>.</p> <pre><code>matches = (\n    jsonpath.query(\"$.foo..bar\", data)\n    .skip(5)\n    .limit(10)\n)\n\nfor match in matches\n    ...\n</code></pre> <p><code>Query.tail()</code> will get the last n results.</p> <pre><code>for match in jsonpath.query(\"$.foo..bar\", data).tail(5):\n    ...\n</code></pre> <p>Get values for each match using <code>Query.values()</code>.</p> <pre><code>for obj in jsonpath.query(\"$.foo..bar\", data).limit(5).values():\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>path</code> <p>The JSONPath as a string.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>A JSON document or Python object implementing the <code>Sequence</code> or <code>Mapping</code> interfaces.</p> <p> TYPE: <code>JSONData</code> </p> <code>filter_context</code> <p>Arbitrary data made available to filters using the filter context selector.</p> <p> TYPE: <code>Optional[FilterContextVars]</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>When <code>True</code>, compile and evaluate with strict compliance with RFC 9535.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Query</code> <p>A query iterator.</p> RAISES DESCRIPTION <code>JSONPathSyntaxError</code> <p>If the path is invalid.</p> <code>JSONPathTypeError</code> <p>If a filter expression attempts to use types in an incompatible way.</p>"},{"location":"custom_api/","title":"Low Level API Reference","text":""},{"location":"custom_api/#jsonpath.token.Token","title":"jsonpath.token.Token","text":"<p>A token, as returned from <code>lex.Lexer.tokenize()</code>.</p> ATTRIBUTE DESCRIPTION <code>kind</code> <p>The token's type. It is always one of the constants defined in jsonpath.token.py.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The path substring containing text for the token.</p> <p> TYPE: <code>str</code> </p> <code>index</code> <p>The index at which value starts in path.</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>A reference to the complete JSONPath string from which this token derives.</p> <p> TYPE: <code>str</code> </p>"},{"location":"custom_api/#jsonpath.token.Token.position","title":"position","text":"<pre><code>position() -&gt; Tuple[int, int]\n</code></pre> <p>Return the line and column number for the start of this token.</p>"},{"location":"custom_api/#jsonpath.filter.FilterExpression","title":"jsonpath.filter.FilterExpression","text":"<p>               Bases: <code>BaseExpression</code></p> <p>An expression that evaluates to <code>True</code> or <code>False</code>.</p>"},{"location":"custom_api/#jsonpath.filter.FilterExpression.cache_tree","title":"cache_tree","text":"<pre><code>cache_tree() -&gt; FilterExpression\n</code></pre> <p>Return a copy of self.expression augmented with caching nodes.</p>"},{"location":"custom_api/#jsonpath.filter.FilterExpression.cacheable_nodes","title":"cacheable_nodes","text":"<pre><code>cacheable_nodes() -&gt; bool\n</code></pre> <p>Return <code>True</code> if there are any cacheable nodes in this expression tree.</p>"},{"location":"custom_api/#jsonpath.lex.Lexer","title":"jsonpath.lex.Lexer","text":"<p>Tokenize a JSONPath string.</p> <p>Some customization can be achieved by subclassing Lexer and setting class attributes. Then setting <code>lexer_class</code> on a <code>JSONPathEnvironment</code>.</p> ATTRIBUTE DESCRIPTION <code>key_pattern</code> <p>The regular expression pattern used to match mapping keys/properties.</p> <p> </p> <code>logical_not_pattern</code> <p>The regular expression pattern used to match logical negation tokens. By default, <code>not</code> and <code>!</code> are equivalent.</p> <p> </p> <code>logical_and_pattern</code> <p>The regular expression pattern used to match logical and tokens. By default, <code>and</code> and <code>&amp;&amp;</code> are equivalent.</p> <p> </p> <code>logical_or_pattern</code> <p>The regular expression pattern used to match logical or tokens. By default, <code>or</code> and <code>||</code> are equivalent.</p> <p> </p>"},{"location":"custom_api/#jsonpath.lex.Lexer.compile_rules","title":"compile_rules","text":"<pre><code>compile_rules() -&gt; Pattern[str]\n</code></pre> <p>Prepare regular expression rules.</p>"},{"location":"custom_api/#jsonpath.lex.Lexer.compile_strict_rules","title":"compile_strict_rules","text":"<pre><code>compile_strict_rules() -&gt; Pattern[str]\n</code></pre> <p>Prepare regular expression rules in strict mode.</p>"},{"location":"custom_api/#jsonpath.lex.Lexer.tokenize","title":"tokenize","text":"<pre><code>tokenize(path: str) -&gt; Iterator[Token]\n</code></pre> <p>Generate a sequence of tokens from a JSONPath string.</p>"},{"location":"custom_api/#jsonpathparseparser","title":"jsonpath.parse.Parser","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathselectorsjsonpathselector","title":"jsonpath.selectors.JSONPathSelector","text":"<p>TODO:</p>"},{"location":"custom_api/#jsonpathstreamtokenstream","title":"jsonpath.stream.TokenStream","text":"<p>TODO:</p>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Each of the following exceptions has a <code>token</code> property, referencing the <code>Token</code> that caused the error. You can use <code>Token.position()</code> to get the token's line and column number.</p>"},{"location":"exceptions/#jsonpath.JSONPathError","title":"jsonpath.JSONPathError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all errors.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Optional[Token]</code> DEFAULT: <code>None</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathError.message","title":"message  <code>property</code>","text":"<pre><code>message: object\n</code></pre> <p>The exception's error message if one was given.</p>"},{"location":"exceptions/#jsonpath.JSONPathError.detailed_message","title":"detailed_message","text":"<pre><code>detailed_message() -&gt; str\n</code></pre> <p>Return an error message formatted with extra context info.</p>"},{"location":"exceptions/#jsonpath.JSONPathSyntaxError","title":"jsonpath.JSONPathSyntaxError","text":"<p>               Bases: <code>JSONPathError</code></p> <p>An exception raised when parsing a JSONPath string.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathTypeError","title":"jsonpath.JSONPathTypeError","text":"<p>               Bases: <code>JSONPathError</code></p> <p>An exception raised due to a type error.</p> <p>This should only occur at when evaluating filter expressions.</p>"},{"location":"exceptions/#jsonpath.JSONPathIndexError","title":"jsonpath.JSONPathIndexError","text":"<p>               Bases: <code>JSONPathError</code></p> <p>An exception raised when an array index is out of range.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"exceptions/#jsonpath.JSONPathNameError","title":"jsonpath.JSONPathNameError","text":"<p>               Bases: <code>JSONPathError</code></p> <p>An exception raised when an unknown function extension is called.</p> PARAMETER DESCRIPTION <code>args</code> <p>Arguments passed to <code>Exception</code>.</p> <p> TYPE: <code>object</code> DEFAULT: <code>()</code> </p> <code>token</code> <p>The token that caused the error.</p> <p> TYPE: <code>Token</code> </p>"},{"location":"exceptions/#jsonpath.JSONPointerError","title":"jsonpath.JSONPointerError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all JSON Pointer errors.</p>"},{"location":"exceptions/#jsonpath.JSONPointerResolutionError","title":"jsonpath.JSONPointerResolutionError","text":"<p>               Bases: <code>JSONPointerError</code></p> <p>Base exception for those that can be raised during pointer resolution.</p>"},{"location":"exceptions/#jsonpath.JSONPointerIndexError","title":"jsonpath.JSONPointerIndexError","text":"<p>               Bases: <code>JSONPointerResolutionError</code>, <code>IndexError</code></p> <p>An exception raised when an array index is out of range.</p>"},{"location":"exceptions/#jsonpath.JSONPointerKeyError","title":"jsonpath.JSONPointerKeyError","text":"<p>               Bases: <code>JSONPointerResolutionError</code>, <code>KeyError</code></p> <p>An exception raised when a pointer references a mapping with a missing key.</p>"},{"location":"exceptions/#jsonpath.JSONPointerTypeError","title":"jsonpath.JSONPointerTypeError","text":"<p>               Bases: <code>JSONPointerResolutionError</code>, <code>TypeError</code></p> <p>An exception raised when a pointer resolves a string against a sequence.</p>"},{"location":"exceptions/#jsonpath.RelativeJSONPointerError","title":"jsonpath.RelativeJSONPointerError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all Relative JSON Pointer errors.</p>"},{"location":"exceptions/#jsonpath.RelativeJSONPointerIndexError","title":"jsonpath.RelativeJSONPointerIndexError","text":"<p>               Bases: <code>RelativeJSONPointerError</code></p> <p>An exception raised when modifying a pointer index out of range.</p>"},{"location":"exceptions/#jsonpath.RelativeJSONPointerSyntaxError","title":"jsonpath.RelativeJSONPointerSyntaxError","text":"<p>               Bases: <code>RelativeJSONPointerError</code></p> <p>An exception raised when we fail to parse a relative JSON Pointer.</p>"},{"location":"exceptions/#jsonpath.JSONPatchError","title":"jsonpath.JSONPatchError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all JSON Patch errors.</p>"},{"location":"exceptions/#jsonpath.JSONPatchTestFailure","title":"jsonpath.JSONPatchTestFailure","text":"<p>               Bases: <code>JSONPatchError</code></p> <p>An exception raised when a JSON Patch test op fails.</p>"},{"location":"functions/","title":"Filter Functions","text":"<p>A filter function is a named function that can be called as part of a filter selector. Here we describe built in filters. You can define your own function extensions too.</p> <p>Note</p> <p>If you pass <code>strict=True</code> when calling <code>findall()</code>, <code>finditer()</code>, etc., Only standard functions - those defined by RFC 9535 - will be enabled. The standard functions are <code>count</code>, <code>length</code>, <code>match</code>, <code>search</code> and <code>value</code>.</p>"},{"location":"functions/#count","title":"<code>count()</code>","text":"<pre><code>count(obj: object) -&gt; Optional[int]\n</code></pre> <p>Return the number of items in obj. If the object does not respond to Python's <code>len()</code> function, <code>None</code> is returned.</p> <pre><code>$.categories[?count(@.products.*) &gt;= 2]\n</code></pre>"},{"location":"functions/#isinstance","title":"<code>isinstance()</code>","text":"<p>New in version 0.6.0</p> <pre><code>isinstance(obj: object, t: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the type of obj matches t. This function allows t to be one of several aliases for the real Python \"type\". Some of these aliases follow JavaScript/JSON semantics.</p> type aliases UNDEFINED \"undefined\", \"missing\" None \"null\", \"nil\", \"None\", \"none\" str \"str\", \"string\" Sequence (array-like) \"array\", \"list\", \"sequence\", \"tuple\" Mapping (dict-like) \"object\", \"dict\", \"mapping\" bool \"bool\", \"boolean\" int \"number\", \"int\" float \"number\", \"float\" <p>For example :</p> <pre><code>$.categories[?isinstance(@.length, 'number')]\n</code></pre> <p>And <code>is()</code> is an alias for <code>isinstance()</code>:</p> <pre><code>$.categories[?is(@.length, 'number')]\n</code></pre>"},{"location":"functions/#keys","title":"<code>keys()</code>","text":"<p>New in version 2.0.0</p> <pre><code>keys(value: object) -&gt; Tuple[str, ...] | Nothing\n</code></pre> <p>Return a list of keys from an object/mapping. If <code>value</code> does not have a <code>keys()</code> method, the special Nothing value is returned.</p> <p>Note</p> <p><code>keys()</code> is not registered with the default JSONPath environment. The keys selector and keys filter selector are usually the better choice when strict compliance with the specification is not needed.</p> <p>You can register <code>keys()</code> with your JSONPath environment like this:</p> <pre><code>from jsonpath import JSONPathEnvironment\nfrom jsonpath import function_extensions\n\nenv = JSONPathEnvironment()\nenv.function_extensions[\"keys\"] = function_extensions.Keys()\n</code></pre> <pre><code>$.some[?'thing' in keys(@)]\n</code></pre>"},{"location":"functions/#length","title":"<code>length()</code>","text":"<pre><code>length(obj: object) -&gt; Optional[int]\n</code></pre> <p>Return the number of items in the input object. If the object does not respond to Python's <code>len()</code> function, <code>None</code> is returned.</p> <pre><code>$.categories[?length(@) &gt; 1]\n</code></pre>"},{"location":"functions/#match","title":"<code>match()</code>","text":"<pre><code>match(obj: object, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if obj is a string and is a full match to the regex pattern.</p> <pre><code>$..products[?match(@.title, \".+ainers.+\")]\n</code></pre> <p>If pattern is a string literal, it will be compiled at compile time, and raise a <code>JSONPathTypeError</code> at compile time if it's invalid.</p> <p>If pattern is a query and the result is not a valid regex, <code>False</code> is returned.</p>"},{"location":"functions/#search","title":"<code>search()</code>","text":"<pre><code>search(obj: object, pattern: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if obj is a string and it contains the regexp pattern.</p> <pre><code>$..products[?search(@.title, \"ainers\")]\n</code></pre> <p>If pattern is a string literal, it will be compiled at compile time, and raise a <code>JSONPathTypeError</code> at compile time if it's invalid.</p> <p>If pattern is a query and the result is not a valid regex, <code>False</code> is returned.</p>"},{"location":"functions/#startswith","title":"<code>startswith()</code>","text":"<p>New in version 2.0.0</p> <pre><code>startswith(value: str, prefix: str) -&gt; bool\n</code></pre> <p>Return <code>True</code> if <code>value</code> starts with <code>prefix</code>. If <code>value</code> or <code>prefix</code> are not strings, <code>False</code> is returned.</p> <pre><code>$[?startswith(@, 'ab')]\n</code></pre>"},{"location":"functions/#typeof","title":"<code>typeof()</code>","text":"<p>New in version 0.6.0</p> <pre><code>typeof(obj: object) -&gt; str\n</code></pre> <p>Return the type of obj as a string. The strings returned from this function use JavaScript/JSON terminology like \"string\", \"array\" and \"object\", much like the result of JavaScript's <code>typeof</code> operator.</p> <pre><code>$.categories[?typeof(@.length) == 'number']\n</code></pre> <p><code>type()</code> is and alias for <code>typeof()</code>.</p> <p><code>jsonpath.function_extensions.TypeOf</code> takes a <code>single_number_type</code> argument, which controls the behavior of <code>typeof()</code> when given and int or float. By default, <code>single_number_type</code> is <code>True</code> and <code>\"number\"</code> is returned. Register a new instance of <code>TypeOf</code> with a <code>JSONPathEnvironment</code> with <code>single_number_type</code> set to <code>False</code> and <code>\"int\"</code> and <code>\"float\"</code> will be returned when given integers and floats, respectively.</p> instance type string UNDEFINED \"undefined\" None \"null\" str \"string\" Sequence (array-like) \"array\" Mapping (dict-like) \"object\" bool \"boolean\" int \"number\" or \"int\" if <code>single_number_type</code> is <code>False</code> float \"number\" or \"float\" if <code>single_number_type</code> is <code>False</code>"},{"location":"functions/#value","title":"<code>value()</code>","text":"<pre><code>value(nodes: object) -&gt; object | undefined\n</code></pre> <p>Return the first value from nodes resulting from a JSONPath query, if there is only one node, or <code>undefined</code> otherwise.</p> <pre><code>$..products[?value(@.price) == 9]\n</code></pre>"},{"location":"pointers/","title":"JSON Pointers","text":"<p>New in version 0.8.0</p> <p>JSON Pointer (RFC 6901) is a string syntax for targeting a single value (JSON object, array, or scalar) within a JSON document. Unlike a JSONPath expression, which can yield multiple values, a JSON Pointer resolves to at most one value.</p> <p>JSON Pointers are a fundamental component of JSON Patch (RFC 6902), where each patch operation must have at least one pointer identifying the target location to modify.</p> Extensions to RFC 6901 <p>We have extended RFC 6901 to support:</p> <ul> <li>Interoperability with the JSONPath keys selector (<code>~</code>)</li> <li>A special non-standard syntax for targeting keys or indices themselves, used in conjunction with Relative JSON Pointer</li> </ul> <p>Keys Selector Compatibility</p> <p>The JSONPath keys selector (<code>.~</code> or <code>[~]</code>) allows expressions to target the keys of an object, rather than their associated values. To maintain compatibility when translating between JSONPath and JSON Pointer, our implementation includes special handling for this selector.</p> <p>While standard JSON Pointers always refer to values, we ensure that paths derived from expressions like <code>$.categories.~</code> can be represented in our pointer system. This is especially important when converting from JSONPath to JSON Pointer or when evaluating expressions that mix value and key access.</p> <p>Key/Index Pointers (<code>#&lt;key or index&gt;</code>)</p> <p>This non-standard pointer form represents keys or indices themselves, not the values they map to. Examples:</p> <ul> <li><code>#foo</code> points to the object key <code>\"foo\"</code> (not the value at <code>\"foo\"</code>)</li> <li><code>#0</code> points to the index <code>0</code> of an array (not the value at that index)</li> </ul> <p>This syntax is introduced to support the full capabilities of Relative JSON Pointer, which allows references to both values and the keys or indices that identify them. To ensure that any <code>RelativeJSONPointer</code> can be losslessly converted into a <code>JSONPointer</code>, we use the <code>#&lt;key or index&gt;</code> form to represent these special cases.</p>"},{"location":"pointers/#example","title":"Example","text":"<pre><code>from jsonpath import RelativeJSONPointer\n\nrjp = RelativeJSONPointer(\"1#\")\nprint(repr(rjp.to(\"/items/0/name\")))  # JSONPointer('/items/#0')\n</code></pre>"},{"location":"pointers/#resolvedata","title":"<code>resolve(data)</code>","text":"<p>Resolve this pointer against data. data can be a file-like object or string containing JSON formatted data, or a Python <code>Mapping</code> or <code>Sequence</code>, like a dictionary or list.</p> <pre><code>from jsonpath import JSONPointer\n\nexample_data = {\"foo\": {\"bar\": [1, 2, 3]}}\npointer = JSONPointer(\"/foo/bar/0\")\n\nprint(pointer.resolve(example_data))  # 1\n</code></pre>"},{"location":"pointers/#resolve_parentdata","title":"<code>resolve_parent(data)</code>","text":"<p>Resolve this pointer against data, return the object and its parent as a <code>(parent, object)</code> tuple.</p> <p>If object does not exist in data but parent does, <code>(parent, UNDEFINED)</code> will be returned. Where <code>jsonpath.pointer.UNDEFINED</code> indicates the lack of a value.</p> <p>If this pointer points to the JSON document root, parent will be <code>None</code>.</p> <pre><code>from jsonpath import JSONPointer\n\nexample_data = {\"foo\": {\"bar\": [1, 2, 3]}}\n\npointer = JSONPointer(\"/foo/bar/0\")\nprint(pointer.resolve_parent(example_data))  # ([1, 2, 3], 1)\n\n# 'thing' does not exist\npointer = JSONPointer(\"/foo/thing\")\nprint(pointer.resolve_parent(example_data))  # ({'bar': [1, 2, 3]}, &lt;jsonpath.pointer._Undefined object at 0x7f0c7cf77040&gt;)\n\npointer = JSONPointer(\"\")\nprint(pointer.resolve_parent(example_data))  # (None, {'foo': {'bar': [1, 2, 3]}})\n</code></pre>"},{"location":"pointers/#existsdata","title":"<code>exists(data)</code>","text":"<p>New in version 0.9.0</p> <p>Return True if this pointer can be resolved against data, or False otherwise. Note that <code>JSONPointer.resolve()</code> can return legitimate falsy values that form part of the target JSON document. This method will return <code>True</code> if a falsy value is found.</p> <pre><code>from jsonpath import JSONPointer\n\nexample_data = {\"foo\": {\"bar\": [1, 2, 3]}, \"baz\": False}\n\npointer = JSONPointer(\"/foo/bar/0\")\nprint(pointer.exists(example_data))  # True\n\npointer = JSONPointer(\"/foo/bar/9\")\nprint(pointer.exists(example_data))  # False\n\npointer = JSONPointer(\"/baz\")\nprint(pointer.exists(example_data))  # True\n</code></pre>"},{"location":"pointers/#joinparts","title":"<code>join(*parts)</code>","text":"<p>New in version 0.9.0</p> <p>Join this pointer with parts. Each part is expected to be a JSON Pointer string, possibly without a leading slash. If a part does have a leading slash, the previous pointer is ignored and a new <code>JSONPointer</code> is created, and processing of remaining parts continues.</p> <p><code>join()</code> is equivalent to using the slash (<code>/</code>) operator for each argument.</p> <pre><code>from jsonpath import JSONPointer\n\npointer = JSONPointer(\"/foo/bar\")\nprint(pointer)  # /foo/bar\nprint(pointer.join(\"baz\"))  # /foo/bar/baz\nprint(pointer.join(\"baz\", \"0\"))  # /foo/bar/baz/0\n</code></pre>"},{"location":"pointers/#parent","title":"<code>parent()</code>","text":"<p>New in version 0.9.0</p> <p>Return this pointer's parent as a new <code>JSONPointer</code>. If this pointer points to the document root, self is returned.</p> <pre><code>from jsonpath import JSONPointer\n\npointer = JSONPointer(\"/foo/bar\")\nprint(pointer)  # /foo/bar\nprint(pointer.parent())  # /foo\n</code></pre>"},{"location":"pointers/#is_relative_topointer","title":"<code>is_relative_to(pointer)</code>","text":"<p>Return True if this pointer points to a child of the argument pointer, which must be a <code>JSONPointer</code> instance.</p> <pre><code>from jsonpath import JSONPointer\n\npointer = JSONPointer(\"/foo/bar\")\n\nanother_pointer = JSONPointer(\"/foo/bar/0\")\nprint(another_pointer.is_relative_to(pointer))  # True\n\nanother_pointer = JSONPointer(\"/foo/baz\")\nprint(another_pointer.is_relative_to(pointer))  # False\n</code></pre>"},{"location":"pointers/#torel","title":"<code>to(rel)</code>","text":"<p>New in version 0.9.0</p> <p>Return a new <code>JSONPointer</code> relative to this pointer. rel should be a <code>RelativeJSONPointer</code> instance or a string following Relative JSON Pointer syntax.</p> <pre><code>from jsonpath import JSONPointer\n\ndata = {\"foo\": {\"bar\": [1, 2, 3], \"baz\": [4, 5, 6]}}\npointer = JSONPointer(\"/foo/bar/2\")\n\nprint(pointer.resolve(data))  # 3\nprint(pointer.to(\"0-1\").resolve(data))  # 2\nprint(pointer.to(\"2/baz/2\").resolve(data))  # 6\n</code></pre> <p>A <code>RelativeJSONPointer</code> can be instantiated for repeated application to multiple different pointers.</p> <pre><code>from jsonpath import JSONPointer\nfrom jsonpath import RelativeJSONPointer\n\ndata = {\"foo\": {\"bar\": [1, 2, 3], \"baz\": [4, 5, 6], \"some\": \"thing\"}}\n\nsome_pointer = JSONPointer(\"/foo/bar/0\")\nanother_pointer = JSONPointer(\"/foo/baz/2\")\nrel = RelativeJSONPointer(\"2/some\")\n\nprint(rel.to(some_pointer).resolve(data))  # thing\nprint(rel.to(another_pointer).resolve(data))  # thing\n</code></pre>"},{"location":"pointers/#slash-operator","title":"Slash Operator","text":"<p>New in version 0.9.0</p> <p>The slash operator allows you to create pointers that are children of an existing pointer.</p> <pre><code>from jsonpath import JSONPointer\n\npointer = JSONPointer(\"/users\")\nchild_pointer = pointer / \"score\" / \"0\"\nanother_child_pointer = pointer / \"score/1\"\n\nprint(child_pointer)  # \"/users/score/0\"\nprint(another_child_pointer)  # \"/users/score/1\"\n</code></pre>"},{"location":"query/","title":"Query Iterators","text":"<p>New in version 1.1.0</p> <p>In addition to <code>findall()</code> and <code>finditer()</code>, covered in the quick start guide, Python JSONPath offers a fluent query iterator interface.</p> <p><code>Query</code> objects provide chainable methods for manipulating a <code>JSONPathMatch</code> iterator, like you'd get from <code>finditer()</code>. Obtain a <code>Query</code> object using the package-level <code>query()</code> function, <code>JSONPathEnvironment.query()</code> or using the <code>query()</code> method of a compiled JSONPath.</p> <p>This example uses the query API to skip the first five matches, limit the total number of matches to ten, then get the value associated with each match.</p> <pre><code>from jsonpath import query\n\n# data = ...\n\nvalues = (\n    query(\"$.some[?@.thing]\", data)\n    .skip(5)\n    .limit(10)\n    .values()\n)\n\nfor value in values:\n    # ...\n</code></pre> <p><code>Query</code> objects are iterable and can only be iterated once. Pass the query to <code>list()</code> (or other sequence) to get a list of results that can be iterated multiple times or otherwise manipulated.</p> <pre><code>from jsonpath import query\n\n# data = ...\n\nvalues = list(\n    query(\"$.some[?@.thing]\", data)\n    .skip(5)\n    .limit(10)\n    .values()\n)\n\nprint(values[1])\n</code></pre>"},{"location":"query/#chainable-methods","title":"Chainable methods","text":"<p>The following <code>Query</code> methods all return <code>self</code> (the same <code>Query</code> instance), so method calls can be chained to further manipulate the underlying iterator.</p> Method Aliases Description <code>skip(n: int)</code> <code>drop</code> Drop up to n matches from the iterator. <code>limit(n: int)</code> <code>head</code>, <code>first</code> Yield at most n matches from the iterator. <code>tail(n: int)</code> <code>last</code> Drop matches from the iterator up to the last n."},{"location":"query/#terminal-methods","title":"Terminal methods","text":"<p>These are terminal methods of the <code>Query</code> class. They can not be chained.</p> Method Aliases Description <code>values()</code> Return an iterable of objects, one for each match in the iterable. <code>locations()</code> Return an iterable of normalized paths, one for each match in the iterable. <code>items()</code> Return an iterable of (object, normalized path) tuples, one for each match in the iterable. <code>pointers()</code> Return an iterable of <code>JSONPointer</code> instances, one for each match in the iterable. <code>first_one()</code> <code>one</code> Return the first <code>JSONPathMatch</code>, or <code>None</code> if there were no matches. <code>last_one()</code> Return the last <code>JSONPathMatch</code>, or <code>None</code> if there were no matches."},{"location":"query/#take","title":"Take","text":"<p><code>Query.take(self, n: int)</code> returns a new <code>Query</code> instance, iterating over the next n matches. It leaves the existing query in a safe state, ready to resume iteration of remaining matches.</p> <pre><code>from jsonpath import query\n\nit = query(\"$.some.*\", {\"some\": [0, 1, 2, 3]})\n\nfor match in it.take(2):\n    print(match.value)  # 0, 1\n\nfor value in it.values():\n    print(value)  # 2, 3\n</code></pre>"},{"location":"query/#tee","title":"Tee","text":"<p><code>tee()</code> creates multiple independent queries from one query iterator. It is not safe to use the initial <code>Query</code> instance after calling <code>tee()</code>.</p> <pre><code>from jsonpath import query\n\nit1, it2 = query(\"$.some[?@.thing]\", data).tee()\n\nhead = it1.head(10) # first 10 matches\ntail = it2.tail(10) # last 10 matches\n</code></pre>"},{"location":"query/#select","title":"Select","text":"<p><code>select(*expressions, projection=Projection.RELATIVE)</code> performs JSONPath match projection, selecting a subset of values according to one or more JSONPath query expressions relative to the match location. For example:</p> <pre><code>from jsonpath import query\n\ndata = {\n    \"categories\": [\n        {\n            \"name\": \"footwear\",\n            \"products\": [\n                {\n                    \"title\": \"Trainers\",\n                    \"description\": \"Fashionable trainers.\",\n                    \"price\": 89.99,\n                },\n                {\n                    \"title\": \"Barefoot Trainers\",\n                    \"description\": \"Running trainers.\",\n                    \"price\": 130.00,\n                    \"social\": {\"likes\": 12, \"shares\": 7},\n                },\n            ],\n        },\n        {\n            \"name\": \"headwear\",\n            \"products\": [\n                {\n                    \"title\": \"Cap\",\n                    \"description\": \"Baseball cap\",\n                    \"price\": 15.00,\n                },\n                {\n                    \"title\": \"Beanie\",\n                    \"description\": \"Winter running hat.\",\n                    \"price\": 9.00,\n                },\n            ],\n        },\n    ],\n    \"price_cap\": 10,\n}\n\nfor product in query(\"$..products.*\", data).select(\"title\", \"price\"):\n    print(product)\n</code></pre> <p>Which selects just the <code>title</code> and <code>price</code> fields for each product.</p> <pre><code>{'title': 'Trainers', 'price': 89.99}\n{'title': 'Barefoot Trainers', 'price': 130.0}\n{'title': 'Cap', 'price': 15.0}\n{'title': 'Beanie', 'price': 9.0}\n</code></pre> <p>Without the call to <code>select()</code>, we'd get all fields in each product object.</p> <pre><code># ...\n\nfor product in query(\"$..products.*\", data).values():\n    print(product)\n</code></pre> <pre><code>{'title': 'Trainers', 'description': 'Fashionable trainers.', 'price': 89.99}\n{'title': 'Barefoot Trainers', 'description': 'Running trainers.', 'price': 130.0, 'social': {'likes': 12, 'shares': 7}}\n{'title': 'Cap', 'description': 'Baseball cap', 'price': 15.0}\n{'title': 'Beanie', 'description': 'Winter running hat.', 'price': 9.0}\n</code></pre> <p>We can select nested values too, and arguments to <code>select()</code> can be pre-compiled paths.</p> <pre><code>import jsonpath\n\n# ...\n\nprojection = (jsonpath.compile(\"title\"), jsonpath.compile(\"social.shares\"))\n\nfor product in jsonpath.query(\"$..products.*\", data).select(*projection):\n    print(product)\n</code></pre> <pre><code>{'title': 'Trainers'}\n{'title': 'Barefoot Trainers', 'social': {'shares': 7}}\n{'title': 'Cap'}\n{'title': 'Beanie'}\n</code></pre> <p>And flatten the selection into a sequence of values.</p> <pre><code>from jsonpath import Projection\n\n# ...\n\nfor product in query(\"$..products.*\", data).select(\n    \"title\", \"social.shares\", projection=Projection.FLAT\n):\n    print(product)\n</code></pre> <pre><code>['Trainers']\n['Barefoot Trainers', 7]\n['Cap']\n['Beanie']\n</code></pre> <p>Or project the selection from the JSON value root.</p> <pre><code># ..\n\nfor product in query(\"$..products[?@.social]\", data).select(\n    \"title\",\n    \"social.shares\",\n    projection=Projection.ROOT,\n):\n    print(product)\n</code></pre> <pre><code>{'categories': [{'products': [{'title': 'Barefoot Trainers', 'social': {'shares': 7}}]}]}\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This page gets you started using JSONPath, JSON Pointer and JSON Patch wih Python. See JSONPath Syntax for information on JSONPath selector syntax.</p>"},{"location":"quickstart/#findallpath-data","title":"<code>findall(path, data)</code>","text":"<p>Find all values matching a JSONPath query using <code>jsonpath.findall()</code>.</p> <p>This function takes two arguments:</p> <ul> <li><code>path</code>: a JSONPath query as a string (e.g. <code>\"$.users[*].name\"</code>)</li> <li><code>data</code>: the JSON document to query</li> </ul> <p>It always returns a list of matched values, even if the path resolves to a single result or nothing at all.</p> <p>The <code>data</code> argument can be:</p> <ul> <li>A Python <code>Mapping</code> (e.g. <code>dict</code>) or <code>Sequence</code> (e.g. <code>list</code>)</li> <li>A JSON-formatted string</li> <li>A file-like object containing JSON</li> </ul> <p>For example, the following query extracts all user names from a dictionary containing a list of user objects:</p> <pre><code>import jsonpath\n\ndata = {\n    \"users\": [\n        {\n            \"name\": \"Sue\",\n            \"score\": 100,\n        },\n        {\n            \"name\": \"John\",\n            \"score\": 86,\n        },\n        {\n            \"name\": \"Sally\",\n            \"score\": 84,\n        },\n        {\n            \"name\": \"Jane\",\n            \"score\": 55,\n        },\n    ]\n}\n\nuser_names = jsonpath.findall(\"$.users.*.name\", data)\n</code></pre> <p>Where <code>user_names</code> is now equal to:</p> <pre><code>[\"Sue\", \"John\", \"Sally\", \"Jane\"]\n</code></pre> <p>If the same data were in a file called <code>users.json</code>, we might use <code>findall()</code> like this:</p> <pre><code>import jsonpath\n\nwith open(\"users.json\") as fd:\n    user_names = jsonpath.findall(\"$.users.*.name\", fd)\n</code></pre>"},{"location":"quickstart/#finditerpath-data","title":"<code>finditer(path, data)</code>","text":"<p>Use <code>jsonpath.finditer()</code> to iterate over instances of <code>jsonpath.JSONPathMatch</code> for every object in data that matches path. It accepts the same arguments as <code>findall()</code>, a query string and data from which to select matches.</p> <pre><code>import jsonpath\n\ndata = {\n    \"users\": [\n        {\n            \"name\": \"Sue\",\n            \"score\": 100,\n        },\n        {\n            \"name\": \"John\",\n            \"score\": 86,\n        },\n        {\n            \"name\": \"Sally\",\n            \"score\": 84,\n        },\n        {\n            \"name\": \"Jane\",\n            \"score\": 55,\n        },\n    ]\n}\n\nmatches = jsonpath.finditer(\"$.users.*.name\", data)\nfor match in matches:\n    print(matches)\n</code></pre> <p>The string representation of a <code>JSONPathMatch</code> shows the matched object and the canonical path to that object.</p> <pre><code>'Sue' @ $['users'][0]['name']\n'John' @ $['users'][1]['name']\n'Sally' @ $['users'][2]['name']\n'Jane' @ $['users'][3]['name']\n</code></pre> <p>The selected object is available from a <code>JSONPathMatch</code> as <code>obj</code> and its path, as a string, as <code>path</code>. Other useful properties of <code>JSONPathMatch</code> include a reference to the parent match, a list of child matches, and a <code>parts</code> tuple of keys and indices that make up the path.</p>"},{"location":"quickstart/#compilepath","title":"<code>compile(path)</code>","text":"<p>When you have a JSONPath query that needs to be matched against different data repeatedly, you can compile the path ahead of time using <code>jsonpath.compile()</code>. It takes a query as a string and returns an instance of <code>JSONPath</code>. <code>JSONPath</code> has <code>findall()</code> and <code>finditer()</code> methods that behave similarly to package-level <code>findall()</code> and <code>finditer()</code>, just without the <code>path</code> argument.</p> <pre><code>import jsonpath\n\nsome_data = {\n    \"users\": [\n        {\n            \"name\": \"Sue\",\n            \"score\": 100,\n        },\n        {\n            \"name\": \"John\",\n            \"score\": 86,\n        },\n    ]\n}\n\nother_data = {\n    \"users\": [\n        {\n            \"name\": \"Sally\",\n            \"score\": 84,\n        },\n        {\n            \"name\": \"Jane\",\n            \"score\": 55,\n        },\n    ]\n}\n\npath = jsonpath.compile(\"$.users.*.name\")\n\nsome_users = path.findall(some_data)\nother_users = path.findall(other_data)\n</code></pre>"},{"location":"quickstart/#matchpath-data","title":"<code>match(path, data)</code>","text":"<p>New in version 0.8.0</p> <p>Get a <code>jsonpath.JSONPathMatch</code> instance for the first match found in data. If there are no matches, <code>None</code> is returned. <code>match()</code> accepts the same arguments as <code>findall()</code>.</p> <pre><code>import jsonpath\n\ndata = {\n    \"users\": [\n        {\n            \"name\": \"Sue\",\n            \"score\": 100,\n        },\n        {\n            \"name\": \"John\",\n            \"score\": 86,\n        },\n        {\n            \"name\": \"Sally\",\n            \"score\": 84,\n        },\n        {\n            \"name\": \"Jane\",\n            \"score\": 55,\n        },\n    ]\n}\n\nmatch = jsonpath.match(\"$.users[?@.score &gt; 85].name\", data)\nif match:\n    print(match)  # 'Sue' @ $['users'][0]['name']\n    print(match.obj)  # Sue\n</code></pre>"},{"location":"quickstart/#pointerresolvepointer-data","title":"<code>pointer.resolve(pointer, data)</code>","text":"<p>New in version 0.8.0</p> <p>Resolves a JSON Pointer (RFC 6901) against a JSON document, returning the value located at the specified path.</p> <p>The <code>pointer</code> argument can be either:</p> <ul> <li>A string representation of a JSON Pointer (e.g., <code>\"/foo/bar/0\"</code>)</li> <li>A list of unescaped pointer segments (e.g., <code>[\"foo\", \"bar\", \"0\"]</code>)</li> </ul> <p>The <code>data</code> argument can be:</p> <ul> <li>A Python data structure (<code>dict</code>, <code>list</code>, etc.)</li> <li>A JSON-formatted string</li> <li>A file-like object containing JSON</li> </ul> <pre><code>from jsonpath import pointer\n\ndata = {\n    \"users\": [\n        {\n            \"name\": \"Sue\",\n            \"score\": 100,\n        },\n        {\n            \"name\": \"John\",\n            \"score\": 86,\n        },\n        {\n            \"name\": \"Sally\",\n            \"score\": 84,\n        },\n        {\n            \"name\": \"Jane\",\n            \"score\": 55,\n        },\n    ]\n}\n\nsue_score = pointer.resolve(\"/users/0/score\", data)\nprint(sue_score)  # 100\n\njane_score = pointer.resolve([\"users\", 3, \"score\"], data)\nprint(jane_score)  # 55\n</code></pre> <p>If the pointer cannot be resolved against the target JSON data \u2014 due to a missing key, an out-of-range index, or an unexpected data type \u2014 an exception will be raised:</p> <ul> <li><code>JSONPointerKeyError</code> \u2013 when a referenced key is missing from an object</li> <li><code>JSONPointerIndexError</code> \u2013 when an array index is out of bounds</li> <li><code>JSONPointerTypeError</code> \u2013 when a path segment expects the wrong type (e.g., indexing into a non-array)</li> </ul> <p>All of these exceptions are subclasses of <code>JSONPointerResolutionError</code>.</p> <p>You can optionally provide a <code>default</code> value to <code>resolve()</code>, which will be returned instead of raising an error if the pointer cannot be resolved.</p> <pre><code>from jsonpath import pointer\n\ndata = {\n    \"users\": [\n        {\n            \"name\": \"Sue\",\n            \"score\": 100,\n        },\n        {\n            \"name\": \"John\",\n            \"score\": 86,\n        },\n    ]\n}\n\nsue_score = pointer.resolve(\"/users/99/score\", data, default=0)\nprint(sue_score)  # 0\n</code></pre> <p>See also <code>JSONPathMatch.pointer()</code>, which builds a <code>JSONPointer</code> from a <code>JSONPathMatch</code>.</p>"},{"location":"quickstart/#patchapplypatch-data","title":"<code>patch.apply(patch, data)</code>","text":"<p>New in version 0.8.0</p> <p>Apply a JSON Patch (RFC 6902) to some data. A JSON Patch defines update operation to perform on a JSON document.</p> <p>patch can be a string or file-like object containing a valid JSON Patch document, or an iterable of dictionaries.</p> <p>data is the target JSON document to modify. If data is a string or file-like object, it will be loaded with json.loads. Otherwise data should be a JSON-like data structure and will be modified in place.</p> <pre><code>from jsonpath import patch\n\npatch_operations = [\n    {\"op\": \"add\", \"path\": \"/some/foo\", \"value\": {\"foo\": {}}},\n    {\"op\": \"add\", \"path\": \"/some/foo\", \"value\": {\"bar\": []}},\n    {\"op\": \"copy\", \"from\": \"/some/other\", \"path\": \"/some/foo/else\"},\n    {\"op\": \"add\", \"path\": \"/some/foo/bar/-\", \"value\": 1},\n]\n\ndata = {\"some\": {\"other\": \"thing\"}}\npatch.apply(patch_operations, data)\nprint(data) # {'some': {'other': 'thing', 'foo': {'bar': [1], 'else': 'thing'}}}\n</code></pre> <p>Use the JSONPatch class to create a patch for repeated application.</p> <pre><code>from jsonpath import JSONPatch\n\npatch = JSONPatch(\n    [\n        {\"op\": \"add\", \"path\": \"/some/foo\", \"value\": {\"foo\": {}}},\n        {\"op\": \"add\", \"path\": \"/some/foo\", \"value\": {\"bar\": []}},\n        {\"op\": \"copy\", \"from\": \"/some/other\", \"path\": \"/some/foo/else\"},\n        {\"op\": \"add\", \"path\": \"/some/foo/bar/-\", \"value\": 1},\n    ]\n)\n\ndata = {\"some\": {\"other\": \"thing\"}}\npatch.apply(data)\nprint(data)  # {'some': {'other': 'thing', 'foo': {'bar': [1], 'else': 'thing'}}}\n</code></pre> <p>JSONPatch also offers a builder API for constructing JSON patch documents. We use strings as JSON Pointers in this example, but existing JSONPointer instances are OK too.</p> <pre><code>from jsonpath import JSONPatch\n\npatch = (\n    JSONPatch()\n    .add(\"/some/foo\", {\"foo\": []})\n    .add(\"/some/foo\", {\"bar\": []})\n    .copy(\"/some/other\", \"/some/foo/else\")\n    .add(\"/some/foo/bar/-\", \"/some/foo/else\")\n)\n\ndata = {\"some\": {\"other\": \"thing\"}}\npatch.apply(data)\nprint(data)  # {'some': {'other': 'thing', 'foo': {'bar': [1], 'else': 'thing'}}}\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What's Next?","text":"<p>Read about the Query Iterators API or user-defined filter functions. Also see how to make extra data available to filters with Extra Filter Context.</p> <p><code>findall()</code>, <code>finditer()</code> and <code>compile()</code> are shortcuts that use the default<code>JSONPathEnvironment</code>. <code>jsonpath.findall(path, data)</code> is equivalent to:</p> <pre><code>jsonpath.JSONPathEnvironment().compile(path).findall(data)\n</code></pre> <p>If you would like to customize Python JSONPath, see Advanced Usage.</p>"},{"location":"syntax/","title":"JSONPath Syntax","text":"<p>Python JSONPath extends the RFC 9535 specification with extra selectors and relaxed rules for convenience. If you need strict compliance with RFC 9535, pass <code>strict=True</code> when calling <code>findall()</code>, <code>finditer()</code>, and similar functions. In strict mode, the syntax and behavior conform to the specification, and no non-standard extensions are registered by default. You can still add them manually if needed.</p> <p>This guide first introduces the standard JSONPath syntax (see the RFC for the formal definition), then explains the non-standard extensions and their semantics.</p> Preconfigured JSONPath Environments <p>Python JSONPath provides two ready-to-use environments:</p> <ul> <li>Default environment \u2013 includes relaxed syntax, non-standard selectors, and additional function extensions.</li> <li>Strict environment \u2013 starts with only the RFC 9535 selectors and functions registered. Non-standard extensions can still be enabled explicitly.</li> </ul> <p>For custom setups, subclass <code>JSONPathEnvironment</code> and override <code>setup_function_extensions()</code>:</p> <pre><code>from jsonpath import JSONPathEnvironment\nfrom jsonpath.function_extensions import StartsWith\n\n\nclass MyJSONPathEnvironment(JSONPathEnvironment):\n    def __init__(self) -&gt; None:\n        super().__init__(strict=True)\n\n    def setup_function_extensions(self) -&gt; None:\n        super().setup_function_extensions()\n        self.function_extensions[\"startswith\"] = StartsWith()\n\n\njsonpath = MyJSONPathEnvironment()\nquery = jsonpath.compile(\"...\")\n</code></pre>"},{"location":"syntax/#jsonpath-terminology","title":"JSONPath Terminology","text":"<p>Think of a JSON document as a tree, objects (mappings) and arrays can contain other objects, arrays, or scalar values. Each of these (object, array, or scalar) is a node in the tree. The outermost object or array is called the root node.</p> <p>In this guide, a JSON \"document\" may refer to:</p> <ul> <li>A file containing valid JSON text</li> <li>A Python string containing valid JSON text</li> <li>A Python object composed of dictionaries (or any Mapping), lists (or any Sequence), strings, numbers, booleans, or <code>None</code></li> </ul> <p>A JSONPath expression (aka \"query\") is made up of a sequence of segments. Each segment contains one or more selectors:</p> <ul> <li>A segment corresponds to a step in the path from one set of nodes to the next.</li> <li>A selector describes how to choose nodes within that step (for example, by name, by index, or by wildcard).</li> </ul> <p>What follows is a description of these selectors, starting with the standard ones defined in RFC 9535.</p>"},{"location":"syntax/#standard-selectors-and-identifiers","title":"Standard selectors and identifiers","text":""},{"location":"syntax/#root-identifier","title":"Root identifier","text":"<p>The root identifier, <code>$</code>, refers to the outermost node in the target document. This can be an object, an array, or a scalar value.</p> <p>A query containing only the root identifier simply returns the entire input document.</p> <p>Example query</p> <pre><code>$\n</code></pre> data<pre><code>{\n  \"categories\": [\n    { \"id\": 1, \"name\": \"fiction\" },\n    { \"id\": 2, \"name\": \"non-fiction\" }\n  ]\n}\n</code></pre> results<pre><code>[\n  {\n    \"categories\": [\n      { \"id\": 1, \"name\": \"fiction\" },\n      { \"id\": 2, \"name\": \"non-fiction\" }\n    ]\n  }\n]\n</code></pre>"},{"location":"syntax/#name-selector","title":"Name selector","text":"<p>A name selector matches the value of an object member by its key. You can write it in either shorthand notation (<code>.thing</code>) or bracket notation (<code>['thing']</code> or <code>[\"thing\"]</code>).</p> <p>Dot notation can be used when the property name is a valid identifier. Bracket notation is required when the property name contains spaces, special characters, or starts with a number.</p> <p>Example query</p> <pre><code>$.book.title\n</code></pre> data<pre><code>{\n  \"book\": {\n    \"title\": \"Moby Dick\",\n    \"author\": \"Herman Melville\"\n  }\n}\n</code></pre> results<pre><code>[\"Moby Dick\"]\n</code></pre>"},{"location":"syntax/#index-selector","title":"Index selector","text":"<p>The index selector selects an element from an array by its index. Indices are zero-based and enclosed in brackets, <code>[0]</code>. If the index is negative, items are selected from the end of the array.</p> <p>Example query</p> <pre><code>$.categories[0].name\n</code></pre> data<pre><code>{\n  \"categories\": [\n    { \"id\": 1, \"name\": \"fiction\" },\n    { \"id\": 2, \"name\": \"non-fiction\" }\n  ]\n}\n</code></pre> results<pre><code>[\"fiction\"]\n</code></pre>"},{"location":"syntax/#wildcard-selector","title":"Wildcard selector","text":"<p>The wildcard selector matches all member values of an object or all elements in an array. It can be written as <code>.*</code> (shorthand notation) or <code>[*]</code> (bracket notation).</p> <p>Example query</p> <pre><code>$.categories[*].name\n</code></pre> data<pre><code>{\n  \"categories\": [\n    { \"id\": 1, \"name\": \"fiction\" },\n    { \"id\": 2, \"name\": \"non-fiction\" }\n  ]\n}\n</code></pre> results<pre><code>[\"fiction\", \"non-fiction\"]\n</code></pre>"},{"location":"syntax/#slice-selector","title":"Slice selector","text":"<p>The slice selector allows you to select a range of elements from an array. A start index, ending index and step size are all optional and separated by colons, <code>[start:end:step]</code>. Negative indices count from the end of the array, just like standard Python slicing.</p> <p>Example query</p> <pre><code>$.items[1:4:2]\n</code></pre> data<pre><code>{\n  \"items\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n}\n</code></pre> results<pre><code>[\"b\", \"d\"]\n</code></pre>"},{"location":"syntax/#filter-selector","title":"Filter selector","text":"<p>Filters allow you to remove nodes from a selection based on a Boolean expression, <code>[?expression]</code>. A filter expression evaluates each node in the context of either the root (<code>$</code>) or current (<code>@</code>) node.</p> <p>When filtering a mapping-like object, <code>@</code> identifies the current member value. When filtering a sequence-like object, <code>@</code> identifies the current element.</p> <p>Comparison operators include <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. Logical operators <code>&amp;&amp;</code> (and) and <code>||</code> (or) can combine terms, and parentheses can be used to group expressions.</p> <p>A filter expression on its own - without a comparison - is treated as an existence test.</p> <p>Example query</p> <pre><code>$..products[?(@.price &lt; $.price_cap)]\n</code></pre> data<pre><code>{\n  \"price_cap\": 10,\n  \"products\": [\n    { \"name\": \"apple\", \"price\": 5 },\n    { \"name\": \"orange\", \"price\": 12 },\n    { \"name\": \"banana\", \"price\": 8 }\n  ]\n}\n</code></pre> results<pre><code>[\n  { \"name\": \"apple\", \"price\": 5 },\n  { \"name\": \"banana\", \"price\": 8 }\n]\n</code></pre> <p>Filter expressions can also call predefined function extensions.</p>"},{"location":"syntax/#more-on-segments","title":"More on segments","text":"<p>So far we've seen shorthand notation (<code>.selector</code>) and segments with just one selector (<code>[selector]</code>). Here we cover the descendant segment and segments with multiple selectors.</p>"},{"location":"syntax/#segments-with-multiple-selectors","title":"Segments with multiple selectors","text":"<p>A segment can include multiple selectors separated by commas and enclosed in square brackets (<code>[selector, selector, ...]</code>). Any valid selector (names, indices, slices, filters, or wildcards) can appear in the list.</p> <p>Example query</p> <pre><code>$.store.book[0,2]\n</code></pre> data<pre><code>{\n  \"store\": {\n    \"book\": [\n      { \"title\": \"Book A\", \"price\": 10 },\n      { \"title\": \"Book B\", \"price\": 12 },\n      { \"title\": \"Book C\", \"price\": 8 }\n    ]\n  }\n}\n</code></pre> results<pre><code>[\n  { \"title\": \"Book A\", \"price\": 10 },\n  { \"title\": \"Book C\", \"price\": 8 }\n]\n</code></pre>"},{"location":"syntax/#descendant-segment","title":"Descendant segment","text":"<p>The descendant segment (<code>..</code>) visits all object member values and array elements under the current object or array, applying the selector or selectors that follow to each visited node. It must be followed by a shorthand selector (names, wildcards, etc.) or a bracketed list of one or more selectors.</p> <p>Example query</p> <pre><code>$..price\n</code></pre> data<pre><code>{\n  \"store\": {\n    \"book\": [\n      { \"title\": \"Book A\", \"price\": 10 },\n      { \"title\": \"Book B\", \"price\": 12 }\n    ],\n    \"bicycle\": { \"color\": \"red\", \"price\": 19.95 }\n  }\n}\n</code></pre> results<pre><code>[10, 12, 19.95]\n</code></pre>"},{"location":"syntax/#non-standard-selectors-and-identifiers","title":"Non-standard selectors and identifiers","text":"<p>The selectors and identifiers described in this section are an extension to the RFC 9535 specification. They are enabled by default. Set <code>strict=True</code> when constructing a <code>JSONPathEnvironment</code>, calling <code>findall()</code>, <code>finditer()</code>, etc. to disable all non-standard features.</p> <p>Also note that when <code>strict=False</code>:</p> <ul> <li>The root identifier (<code>$</code>) is optional and paths starting with a dot (<code>.</code>) are OK. <code>.thing</code> is the same as <code>$.thing</code>, as is <code>thing</code> and <code>$[\"thing\"]</code>.</li> <li>Leading and trailing whitespace is OK.</li> <li>Explicit comparisons to <code>undefined</code> (aka <code>missing</code>) are supported as well as implicit existence tests.</li> </ul>"},{"location":"syntax/#key-selector","title":"Key selector","text":"<p>New in version 2.0.0</p> <p>The key selector, <code>.~name</code> or <code>[~'name']</code>, selects at most one name from an object member. It is syntactically similar to the standard name selector, with the addition of a tilde (<code>~</code>) prefix.</p> <p>When applied to a JSON object, the key selector selects the name from an object member, if that name exists, or nothing if it does not exist. This complements the standard name selector, which select the value from a name/value pair.</p> <p>When applied to an array or primitive value, the key selector selects nothing.</p> <p>Key selector strings must follow the same processing semantics as name selector strings, as described in section 2.3.2.1 of RFC 9535.</p> <p>Info</p> <p>The key selector is introduced to facilitate valid normalized paths for nodes produced by the keys selector and the keys filter selector. I don't expect it will be of much use elsewhere.</p>"},{"location":"syntax/#syntax","title":"Syntax","text":"<pre><code>selector             = name-selector /\n                       wildcard-selector /\n                       slice-selector /\n                       index-selector /\n                       filter-selector /\n                       key-selector /\n                       keys-selector /\n                       keys-filter-selector\n\nkey-selector         = \"~\" name-selector\n\nchild-segment        = bracketed-selection /\n                       (\".\"\n                        (wildcard-selector /\n                         member-name-shorthand /\n                         member-key-shorthand))\n\ndescendant-segment   = \"..\" (bracketed-selection /\n                             wildcard-selector /\n                             member-name-shorthand /\n                             member-key-shorthand)\n\nmember-key-shorthand = \"~\" name-first *name-char\n</code></pre>"},{"location":"syntax/#examples","title":"Examples","text":"Example JSON document<pre><code>{\n  \"a\": [{ \"b\": \"x\", \"c\": \"z\" }, { \"b\": \"y\" }]\n}\n</code></pre> Query Result Result Paths Comment <code>$.a[0].~c</code> <code>\"c\"</code> <code>$['a'][0][~'c']</code> Key of nested object <code>$.a[1].~c</code> Key does not exist <code>$..[~'b']</code> <code>\"b\"</code> <code>\"b\"</code> <code>$['a'][0][~'b']</code> <code>$['a'][1][~'b']</code> Descendant, single quoted key <code>$..[~\"b\"]</code> <code>\"b\"</code> <code>\"b\"</code> <code>$['a'][0][~'b']</code> <code>$['a'][1][~'b']</code> Descendant, double quoted key"},{"location":"syntax/#keys-selector","title":"Keys selector","text":"<p>New in version 0.6.0</p> <p>The keys selector, <code>~</code> or <code>[~]</code>, selects all names from an object\u2019s name/value members. This complements the standard wildcard selector, which selects all values from an object\u2019s name/value pairs.</p> <p>As with the wildcard selector, the order of nodes resulting from a keys selector is not stipulated.</p> <p>When applied to an array or primitive value, the keys selector selects nothing.</p> <p>The normalized path of a node selected using the keys selector uses key selector syntax.</p>"},{"location":"syntax/#syntax_1","title":"Syntax","text":"<pre><code>keys-selector       = \"~\"\n</code></pre>"},{"location":"syntax/#examples_1","title":"Examples","text":"Example JSON document<pre><code>{\n  \"a\": [{ \"b\": \"x\", \"c\": \"z\" }, { \"b\": \"y\" }]\n}\n</code></pre> Query Result Result Paths Comment <code>$.a[0].~</code> <code>\"b\"</code> <code>\"c\"</code> <code>$['a'][0][~'b']</code> <code>$['a'][0][~'c']</code> Object keys <code>$.a.~</code> Array keys <code>$.a[0][~, ~]</code> <code>\"b\"</code> <code>\"c\"</code> <code>\"c\"</code> <code>\"b\"</code> <code>$['a'][0][~'b']</code> <code>$['a'][0][~'c']</code> <code>$['a'][0][~'c']</code> <code>$['a'][0][~'b']</code> Non-deterministic ordering <code>$..[~]</code> <code>\"a\"</code> <code>\"b\"</code> <code>\"c\"</code> <code>\"b\"</code> <code>$[~'a']</code> <code>$['a'][0][~'b']</code> <code>$['a'][0][~'c']</code> <code>$['a'][1][~'b']</code> Descendant keys"},{"location":"syntax/#keys-filter-selector","title":"Keys filter selector","text":"<p>New in version 2.0.0</p> <p>The keys filter selector selects names from an object\u2019s name/value members. It is syntactically similar to the standard filter selector, with the addition of a tilde (<code>~</code>) prefix.</p> <pre><code>~?&lt;logical-expr&gt;\n</code></pre> <p>Whereas the standard filter selector will produce a node for each value from an object\u2019s name/value members - when its expression evaluates to logical true - the keys filter selector produces a node for each name in an object\u2019s name/value members.</p> <p>Logical expression syntax and semantics otherwise match that of the standard filter selector. <code>@</code> still refers to the current member value. See also the current key identifier.</p> <p>When applied to an array or primitive value, the keys filter selector selects nothing.</p> <p>The normalized path of a node selected using the keys filter selector uses key selector syntax.</p>"},{"location":"syntax/#syntax_2","title":"Syntax","text":"<pre><code>filter-selector     = \"~?\" S logical-expr\n</code></pre>"},{"location":"syntax/#examples_2","title":"Examples","text":"Example JSON document<pre><code>[{ \"a\": [1, 2, 3], \"b\": [4, 5] }, { \"c\": { \"x\": [1, 2] } }, { \"d\": [1, 2, 3] }]\n</code></pre> Query Result Result Paths Comment <code>$.*[~?length(@) &gt; 2]</code> <code>\"a\"</code> <code>\"d\"</code> <code>$[0][~'a']</code> <code>$[2][~'d']</code> Conditionally select object keys <code>$.*[~?@.x]</code> <code>\"c\"</code> <code>$[1][~'c']</code> Existence test <code>$[~?(true == true)]</code> Keys from an array"},{"location":"syntax/#singular-query-selector","title":"Singular query selector","text":"<p>New in version 2.0.0</p> <p>The singular query selector consist of an embedded absolute singular query, the result of which is used as an object member name or array element index.</p> <p>If the embedded query resolves to a string or int value, at most one object member value or array element value is selected. Otherwise the singular query selector selects nothing.</p>"},{"location":"syntax/#syntax_3","title":"Syntax","text":"<pre><code>selector                = name-selector /\n                          wildcard-selector /\n                          slice-selector /\n                          index-selector /\n                          filter-selector /\n                          singular-query-selector\n\nsingular-query-selector = abs-singular-query\n</code></pre>"},{"location":"syntax/#examples_3","title":"Examples","text":"<pre><code>{\n  \"a\": {\n    \"j\": [1, 2, 3],\n    \"p\": {\n      \"q\": [4, 5, 6]\n    }\n  },\n  \"b\": [\"j\", \"p\", \"q\"],\n  \"c d\": {\n    \"x\": {\n      \"y\": 1\n    }\n  }\n}\n</code></pre> Query Result Result Path Comment <code>$.a[$.b[1]]</code> <code>{\"q\": [4, 5, 6]}</code> <code>$['a']['p']</code> Object name from embedded singular query <code>$.a.j[$['c d'].x.y]</code> <code>2</code> <code>$['a']['j'][1]</code> Array index from embedded singular query <code>$.a[$.b]</code> Embedded singular query does not resolve to a string or int value"},{"location":"syntax/#current-key-identifier","title":"Current key identifier","text":"<p><code>#</code> is the current key identifier. <code>#</code> will be the name of the current object member, or index of the current array element. This complements the current node identifier (<code>@</code>), which refers to a member value or array element, respectively.</p> <p>It is a syntax error to follow the current key identifier with segments, as if it were a filter query.</p> <p>When used as an argument to a function, the current key is of <code>ValueType</code>, and outside a function call it must be compared.</p>"},{"location":"syntax/#syntax_4","title":"Syntax","text":"<pre><code>comparable             = literal /\n                         singular-query / ; singular query value\n                         function-expr  / ; ValueType\n                         current-key-identifier\n\n\nfunction-argument      = literal /\n                         filter-query / ; (includes singular-query)\n                         logical-expr /\n                         function-expr /\n                         current-key-identifier\n\ncurrent-key-identifier = \"#\"\n</code></pre>"},{"location":"syntax/#examples_4","title":"Examples","text":"Example JSON document<pre><code>{ \"abc\": [1, 2, 3], \"def\": [4, 5], \"abx\": [6], \"aby\": [] }\n</code></pre> Query Result Result Path Comment <code>$[?match(#, '^ab.*') &amp;&amp; length(@) &gt; 0 ]</code> <code>[1,2,3]</code> <code>[6]</code> <code>$['abc']</code> <code>$['abx']</code> Match on object names <code>$.abc[?(# &gt;= 1)]</code> <code>2</code> <code>3</code> <code>$['abc'][1]</code> <code>$['abc'][2]</code> Compare current array index"},{"location":"syntax/#pseudo-root-identifier","title":"Pseudo root identifier","text":"<p>New in version 0.11.0</p> <p>The pseudo root identifier (<code>^</code>) behaves like the standard root identifier (<code>$</code>), but conceptually wraps the target JSON document in a single-element array. This allows the root document itself to be conditionally selected by filters.</p>"},{"location":"syntax/#syntax_5","title":"Syntax","text":"<pre><code>jsonpath-query             = (root-identifier / pseudo-root-identifier) segments\n\nroot-identifier            = \"$\"\npseudo-root-identifier     = \"^\"\n</code></pre>"},{"location":"syntax/#examples_5","title":"Examples","text":"Example JSON data<pre><code>{ \"a\": { \"b\": 42 }, \"n\": 7 }\n</code></pre> Query Result Result Path Comment <code>^[?@.a.b &gt; 7]</code> <code>{ \"a\": { \"b\": 42 } }</code> <code>^[0]</code> Conditionally select the root value <code>^[?@.a.v &gt; value(^.*.n)]</code> <code>{ \"a\": { \"b\": 42 }, \"n\": 7 }</code> <code>^[0]</code> Embedded pseudo root query"},{"location":"syntax/#filter-context-identifier","title":"Filter context identifier","text":"<p>The filter context identifier (<code>_</code>) starts an embedded query, similar to the root identifier (<code>$</code>) and current node identifier (<code>@</code>), but targets JSON-like data passed as the <code>filter_context</code> argument to <code>findall()</code> and <code>finditer()</code>.</p>"},{"location":"syntax/#syntax_6","title":"Syntax","text":"<pre><code>current-node-identifier  = \"@\"\nextra-context-identifier = \"_\"\n\nfilter-query        = rel-query / extra-context-query / jsonpath-query\nrel-query           = current-node-identifier segments\nextra-context-query = extra-context-identifier segments\n\nsingular-query      = rel-singular-query / abs-singular-query / extra-context-singular-query\nrel-singular-query  = current-node-identifier singular-query-segments\nabs-singular-query  = root-identifier singular-query-segments\n\nextra-context-singular-query = extra-context-identifier singular-query-segments\n</code></pre>"},{"location":"syntax/#examples_6","title":"Examples","text":"Example JSON data<pre><code>{ \"a\": [{ \"b\": 42 }, { \"b\": 3 }] }\n</code></pre> Extra JSON data<pre><code>{ \"c\": 42 }\n</code></pre> Query Result Result Path Comment <code>$.a[?@.b == _.c]</code> <code>{ \"b\": 42 }</code> <code>$['a'][0]</code> Comparison with extra context singular query"},{"location":"syntax/#non-standard-operators","title":"Non-standard operators","text":"<p>In addition to the operators described below, the standard logical and operator (<code>&amp;&amp;</code>) is aliased as <code>and</code>, the standard logical or operator (<code>||</code>) is aliased as <code>or</code>, and <code>null</code> is aliased as <code>nil</code> and <code>none</code>.</p> <p>Also, <code>true</code>, <code>false</code>, <code>null</code> and their aliases can start with an upper case letter.</p>"},{"location":"syntax/#membership-operators","title":"Membership operators","text":"<p>The membership operators test whether one value occurs within another.</p> <p>An infix expression using <code>contains</code> evaluates to true if the right-hand side is a member of the left-hand side, and false otherwise.</p> <ul> <li>If the left-hand side is an object and the right-hand side is a string, the result is true if the object has a member with that name.</li> <li>If the left-hand side is an array, the result is true if any element of the array is equal to the right-hand side.</li> <li>For scalars (strings, numbers, booleans, null), <code>contains</code> always evaluates to false.</li> </ul> <p>The <code>in</code> operator is equivalent to <code>contains</code> with operands reversed. This makes <code>contains</code> and <code>in</code> symmetric, so either form may be used depending on which reads more naturally in context.</p> <p>A list literal is a comma separated list of JSONPath expression literals. List should appear on the left-hand side of <code>contains</code> or the right-hand side of <code>in</code>.</p>"},{"location":"syntax/#syntax_7","title":"Syntax","text":"<pre><code>basic-expr          = paren-expr /\n                      comparison-expr /\n                      membership-expr /\n                      test-expr\n\nmembership-expr     = comparable S membership-op S comparable\n\nmembership-operator = \"contains\" / \"in\"\n\nmembership-operand  = literal /\n                      singular-query / ; singular query value\n                      function-expr /  ; ValueType\n                      list-literal\n\nlist-literal        = \"[\" S literal *(S \",\" S literal) S \"]\"\n</code></pre>"},{"location":"syntax/#examples_7","title":"Examples","text":"Example JSON data<pre><code>{\n  \"x\": [{ \"a\": [\"foo\", \"bar\"] }, { \"a\": [\"bar\"] }],\n  \"y\": [{ \"a\": { \"foo\": \"bar\" } }, { \"a\": { \"bar\": \"baz\" } }],\n  \"z\": [{ \"a\": \"foo\" }, { \"a\": \"bar\" }]\n}\n</code></pre> Query Result Result Path Comment <code>$.x[?@.a contains 'foo']</code> <code>{\"a\": [\"foo\", \"bar\"]}</code> <code>$['x'][0]</code> Array contains string literal <code>$.y[?@.a contains 'foo']</code> <code>{\"a\": [\"foo\", \"bar\"]}</code> <code>$['y'][0]</code> Object contains string literal <code>$.x[?'foo' in @.a]</code> <code>{\"a\": [\"foo\", \"bar\"]}</code> <code>$['x'][0]</code> String literal in array <code>$.y[?'foo' in @.a]</code> <code>{\"a\": [\"foo\", \"bar\"]}</code> <code>$['y'][0]</code> String literal in object <code>$.z[?(['bar', 'baz'] contains @.a)]</code> <code>{\"a\": \"bar\"}</code> <code>$['z'][1]</code> List literal contains embedded query"},{"location":"syntax/#regex-operator","title":"Regex operator","text":"<p><code>=~</code> is an infix operator that matches the left-hand side with a regular expression literal on the right-hand side. Regular expression literals use a syntax similar to that found in JavaScript, where the pattern to match is surrounded by slashes, <code>/pattern/</code>, optionally followed by flags, <code>/pattern/flags</code>.</p> <pre><code>$..products[?(@.description =~ /.*trainers/i)]\n</code></pre>"},{"location":"syntax/#union-and-intersection-operators","title":"Union and intersection operators","text":"<p>The union or concatenation operator, <code>|</code>, combines matches from two or more paths.</p> <p>The intersection operator, <code>&amp;</code>, produces matches that are common to both left and right paths.</p> <p>Note that compound queries are not allowed inside filter expressions.</p>"},{"location":"syntax/#syntax_8","title":"Syntax","text":"<pre><code>jsonpath-query          = root-identifier segments\n\ncompound-jsonpath-query = jsonpath-query compound-op jsonpath-query\n\ncompound-op             = \"|\" /\n                          \"&amp;\"\n</code></pre>"},{"location":"syntax/#examples_8","title":"Examples","text":"<pre><code>$..products.*.price | $.price_cap\n</code></pre> <pre><code>$.categories[?(@.name == 'footwear')].products.* &amp; $.categories[?(@.name == 'headwear')].products.*\n</code></pre>"}]}